<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>阵型生成器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 15px;
            color: #fff;
            font-size: 14px;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
        }

        .main-content {
            display: grid;
            grid-template-columns: minmax(420px, 470px) minmax(0, 1fr);
            gap: 15px;
            min-width: 0;
            align-items: start;
            height: calc(100vh - 30px);
        }

        .panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 0;
        }

        .config-panel {
            height: 100%;
            overflow-y: auto;
            padding-right: 4px;
        }

        .workspace-panel {
            height: 100%;
            min-height: 0;
        }

        .config-section {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .config-title {
            font-size: 1em;
            margin-bottom: 10px;
            color: #f093fb;
            font-weight: bold;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .config-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .config-item label {
            white-space: nowrap;
            font-size: 0.9em;
        }

        input[type="number"], input[type="text"], select {
            width: 80px;
            padding: 8px;
            font-size: 0.9em;
            border: none;
            border-radius: 6px;
            background: rgba(255,255,255,0.2);
            color: #fff;
            text-align: center;
        }

        select {
            width: 100%;
            cursor: pointer;
        }

        input[type="text"] {
            width: 100%;
            text-align: left;
        }

        input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.65);
        }

        option {
            background: #1a1a2e;
            color: #fff;
        }

        .slider-wrap {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }

        .short-slider {
            max-width: 250px;
        }

        .short-slider input[type="range"] {
            max-width: 170px;
        }

        input[type="range"] {
            flex: 1;
            accent-color: #38ef7d;
        }

        .slider-value {
            min-width: 38px;
            text-align: right;
            font-size: 0.85em;
            color: #38ef7d;
            font-weight: 600;
        }

        button {
            padding: 10px 20px;
            font-size: 0.9em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 15px rgba(245, 87, 108, 0.4);
        }

        .btn-export {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .btn-export:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 15px rgba(56, 239, 125, 0.4);
        }

        #btnSimulatePlay.simulating {
            --simulate-progress: 0;
            background:
                linear-gradient(
                    90deg,
                    rgba(56, 239, 125, 0.95) 0%,
                    rgba(56, 239, 125, 0.95) calc(var(--simulate-progress) * 1%),
                    rgba(255, 255, 255, 0.22) calc(var(--simulate-progress) * 1%),
                    rgba(255, 255, 255, 0.22) 100%
                );
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.28);
        }

        #btnSimulatePlay.simulating:hover {
            transform: none;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.28);
        }

        #btnSimulatePlay:disabled {
            cursor: wait;
            opacity: 1;
        }

        .global-interaction-blocker {
            position: fixed;
            inset: 0;
            z-index: 9999;
            display: none;
            cursor: not-allowed;
            background: rgba(0, 0, 0, 0.01);
        }

        body.simulation-locked .global-interaction-blocker {
            display: block;
        }

        .btn-generate {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: white;
        }

        .btn-generate:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 15px rgba(250, 112, 154, 0.4);
        }

        .probability-grid {
            grid-template-columns: 1fr;
            gap: 10px;
        }

        .probability-grid .config-item {
            display: block;
        }

        .probability-grid .config-item label {
            display: block;
            white-space: normal;
            margin-bottom: 4px;
        }

        .result-section {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .result-title {
            font-size: 1em;
            margin-bottom: 10px;
            color: #667eea;
            font-weight: bold;
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .result-item {
            background: rgba(255,255,255,0.1);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }

        .result-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #38ef7d;
        }

        .result-label {
            font-size: 0.75em;
            opacity: 0.8;
            margin-top: 2px;
        }

        .pool-section {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .pool-title {
            font-size: 1em;
            margin-bottom: 8px;
            color: #f093fb;
            font-weight: bold;
        }

        .pool-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .pool-item {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.85em;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .pool-count {
            background: rgba(255,255,255,0.3);
            padding: 1px 6px;
            border-radius: 8px;
            font-size: 0.8em;
        }

        .error-msg {
            background: rgba(245, 87, 108, 0.3);
            color: #f5576c;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-size: 0.9em;
        }

        .controls-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .controls-row button {
            flex: 1;
            white-space: nowrap;
        }

        .config-group-actions {
            flex-wrap: nowrap;
        }

        .config-group-actions button {
            min-width: 0;
            padding: 9px 8px;
            font-size: 0.84em;
        }

        .board-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            width: 100%;
            min-width: 0;
            flex: 1;
            overflow: hidden;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.04);
            background-image: var(--board-bg-image, none);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 8px;
        }

        .board-top-tools {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 8px;
        }

        .board-status-row {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .board-bg-control {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 0 0 auto;
        }

        .board-bg-control label {
            font-size: 0.82em;
            color: rgba(231, 240, 255, 0.92);
            white-space: nowrap;
        }

        .board-bg-dropdown {
            position: relative;
            width: 96px;
            min-width: 96px;
        }

        .board-bg-dropdown-toggle {
            width: 100%;
            min-width: 0;
            padding: 6px 8px;
            font-size: 0.82em;
            text-align: left;
            border-radius: 6px;
            background: rgba(255,255,255,0.18);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
        }

        .board-bg-dropdown-toggle:hover {
            transform: none;
            box-shadow: none;
            background: rgba(255,255,255,0.22);
        }

        .board-bg-dropdown-toggle::after {
            content: '▾';
            font-size: 0.72em;
            opacity: 0.9;
        }

        .board-bg-dropdown.open .board-bg-dropdown-toggle::after {
            content: '▴';
        }

        .board-bg-dropdown-menu {
            position: absolute;
            right: 0;
            top: calc(100% + 6px);
            width: 220px;
            max-height: 320px;
            overflow-y: auto;
            display: none;
            padding: 6px;
            border-radius: 8px;
            background: rgba(17, 24, 39, 0.97);
            border: 1px solid rgba(255,255,255,0.24);
            box-shadow: 0 8px 24px rgba(0,0,0,0.38);
            z-index: 10030;
        }

        .board-bg-dropdown.open .board-bg-dropdown-menu {
            display: block;
        }

        .board-bg-option {
            width: 100%;
            padding: 6px;
            border-radius: 6px;
            background: transparent;
            border: 1px solid transparent;
            display: grid;
            grid-template-columns: 64px minmax(0, 1fr);
            gap: 8px;
            align-items: center;
            text-align: left;
            color: #fff;
        }

        .board-bg-option:hover {
            background: rgba(255,255,255,0.14);
            transform: none;
            box-shadow: none;
        }

        .board-bg-option.selected {
            border-color: rgba(56, 239, 125, 0.85);
            background: rgba(56, 239, 125, 0.16);
        }

        .board-bg-option-thumb {
            width: 64px;
            height: 36px;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.22);
            background: rgba(255,255,255,0.04);
        }

        .board-bg-option-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            display: block;
        }

        .board-bg-option-title {
            font-size: 0.82em;
            line-height: 1.2;
        }

        .board-top-actions {
            width: 100%;
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 8px;
        }

        .board-top-actions button {
            width: 100%;
            min-width: 0;
            padding: 9px 10px;
        }

        .board-wrapper {
            transform-origin: top left;
            transition: transform 0.3s ease;
            min-width: 0;
            max-height: none;
            display: flex;
            justify-content: flex-start;
            width: max-content;
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
        }

        .board {
            display: grid;
            gap: 1px;
            background: transparent;
            padding: 8px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.38);
            backdrop-filter: none;
            position: relative;
        }

        .board.play-mode {
            backdrop-filter: none;
        }

        .play-link-overlay {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 30;
            overflow: visible;
        }

        .play-link-path {
            fill: none;
            stroke: #ffd54f;
            stroke-width: 5;
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 0 4px rgba(255, 213, 79, 0.7));
        }

        .cell {
            width: 100%;
            aspect-ratio: 1 / 1;
            background: transparent;
            border-radius: 4px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.15s ease, background-color 0.15s ease, box-shadow 0.15s ease;
            overflow: hidden;
            transform: translateZ(0);
            backface-visibility: hidden;
        }

        .cell.filled {
            background: transparent;
            padding: 2px;
        }

        .board.play-mode .cell.playable-card {
            cursor: pointer;
            transition: transform 0.15s ease;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.35);
        }

        .board.play-mode.play-dragging .cell.playable-card {
            cursor: grabbing;
        }

        .board.play-mode .cell.play-selected {
            transform: none;
            transition: none;
            z-index: 8;
            will-change: transform;
        }

        .board.play-mode .cell.play-dragging {
            transition: none !important;
            z-index: 12;
        }

        .board.play-mode .cell.play-clearing {
            transform: scale(0);
            transition: transform 0.15s ease;
        }

        .board.play-mode.play-shifting {
            pointer-events: none;
        }

        .board.play-mode.play-no-transition .cell,
        .board.play-mode.play-no-transition .cell.filled {
            transition: none !important;
        }

        .board.play-mode .cell.play-shift-anim {
            animation-duration: 0.15s;
            animation-timing-function: linear;
            animation-fill-mode: both;
            animation-name: play-shift-variable;
        }

        @keyframes play-shift-variable {
            from {
                transform: translate3d(var(--shift-start-x, 0px), var(--shift-start-y, 0px), 0);
            }
            to { transform: translate3d(0, 0, 0); }
        }

        .card-image-stack {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .card-image-stack img {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: top center;
            pointer-events: none;
            user-select: none;
            backface-visibility: hidden;
            will-change: transform, opacity;
        }

        .card-image-base {
            z-index: 1;
            transform: scale(1.3);
            transform-origin: top center;
        }

        .card-image-guide {
            z-index: 2;
            transform: scale(1.05);
            transform-origin: top center;
            object-position: top center;
            opacity: 0;
            transition: opacity 0.12s ease;
        }

        .card-image-face {
            z-index: 3;
            transform: scale(1.2);
            transform-origin: top center;
        }

        .board.play-mode .cell.play-selected .card-image-guide {
            opacity: 1;
        }

        .info {
            text-align: left;
            margin-top: 0;
            font-size: 1.08em;
            font-weight: 700;
            letter-spacing: 0.2px;
            opacity: 0.98;
            color: #e7f0ff;
            transition: color 0.15s ease;
            flex: 1;
            min-width: 0;
        }

        .btn-play-retry {
            display: none;
            flex: 0 0 auto;
            padding: 6px 10px;
            font-size: 0.82em;
            border-radius: 7px;
            background: linear-gradient(135deg, #f97316 0%, #ef4444 100%);
            color: #fff;
        }

        .info.info-default {
            color: #e7f0ff;
        }

        .info.info-success {
            color: #86efac;
        }

        .info.info-progress {
            color: #fde68a;
        }

        .info.info-mode {
            color: #93c5fd;
        }

        .info.info-warning {
            color: #fdba74;
        }

        .info.info-error {
            color: #fca5a5;
        }

        .stats-section {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            margin-top: 10px;
        }

        .editor-section {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .editor-board-actions {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px;
            margin-bottom: 10px;
        }

        .editor-board-actions button {
            width: 100%;
            min-width: 0;
        }

        .editor-board-actions button:disabled,
        .editor-board-actions button:disabled:hover {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(0.45);
            transform: none;
            box-shadow: none;
        }

        .editor-tools {
            display: grid;
            grid-template-columns: repeat(5, minmax(0, 1fr));
            gap: 8px;
        }

        .editor-tool {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 6px 4px;
            min-height: 82px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            gap: 4px;
            cursor: pointer;
            transition: border-color 0.2s ease, background-color 0.2s ease;
            color: #fff;
            font-size: 0.72em;
            text-align: center;
            line-height: 1.2;
        }

        .editor-tool:hover {
            background: rgba(255,255,255,0.14);
        }

        .editor-tool.selected {
            border-color: #ffd166;
            box-shadow: 0 0 0 2px rgba(255, 209, 102, 0.3) inset;
            background: rgba(255, 209, 102, 0.18);
        }

        .editor-tool-preview {
            width: 42px;
            height: 50px;
            object-fit: contain;
            pointer-events: none;
            user-select: none;
        }

        .editor-tool[data-tool="attach-iceshell"] .editor-tool-preview {
            transform: translateY(-3px) scale(0.8);
            transform-origin: center center;
        }

        .editor-tool-id {
            opacity: 0.75;
            font-size: 0.92em;
        }

        .editor-tip {
            margin-top: 8px;
            font-size: 0.8em;
            opacity: 0.85;
            line-height: 1.35;
        }

        .card-image-attachment {
            z-index: 4;
            transform-origin: top center;
        }

        .card-image-attachment-fanpai {
            transform: scale(1.3);
        }

        .card-image-attachment-iceshell {
            transform: translateY(2px) scale(1.2);
        }

        .cell.obstacle-cell .card-image-stack {
            width: 100%;
            height: 100%;
        }

        .cell.obstacle-cell {
            padding: 0;
        }

        .cell.obstacle-cell .card-image-obstacle {
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: top center;
            pointer-events: none;
            user-select: none;
        }

        .cell.obstacle-cell .card-image-obstacle-scale130 {
            transform: translateY(5px) scale(1.2);
            transform-origin: top center;
        }

        .card-image-face-bomb {
            transform: scale(0.8);
            transform-origin: top center;
            object-position: top center;
        }

        .board-layout {
            display: grid;
            grid-template-columns: 300px minmax(0, 1fr) 330px;
            gap: 10px;
            width: 100%;
            height: 100%;
            flex: 1;
            align-items: start;
        }

        .board-side-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: auto;
            height: 100%;
            min-height: 0;
            align-self: stretch;
            overflow: hidden;
        }

        .board-editor-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: auto;
            height: 100%;
            overflow: auto;
        }

        .board-layout .result-section,
        .board-layout .stats-section {
            margin-top: 0;
            width: auto;
        }

        .saved-levels-section {
            background: rgba(255,255,255,0.1);
            padding: 12px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 8px;
            height: 100%;
            min-height: 0;
        }

        .saved-level-actions {
            display: grid;
            grid-template-columns: repeat(3, minmax(0, 1fr));
            gap: 8px;
        }

        .saved-level-actions button {
            width: 100%;
            min-width: 0;
        }

        .saved-level-list {
            flex: 1;
            height: 100%;
            min-height: 0;
            max-height: none;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding-right: 2px;
            overscroll-behavior: contain;
        }

        .saved-level-item {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 4px 8px;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            line-height: 1.3;
            height: 46px;
            min-height: 46px;
            max-height: 46px;
            flex: 0 0 46px;
            overflow: hidden;
            position: relative;
        }

        .saved-level-item:hover {
            background: rgba(255,255,255,0.14);
            border-color: rgba(255,255,255,0.35);
        }

        .saved-level-item.saved-level-item-editing {
            background: rgba(59, 130, 246, 0.16);
            border-color: rgba(96, 165, 250, 0.75);
            cursor: default;
        }

        .saved-level-item-main {
            display: grid;
            grid-template-columns: minmax(0, 1fr) auto;
            align-items: center;
            gap: 8px;
            height: 100%;
        }

        .saved-level-item-left {
            min-width: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .saved-level-item-id {
            font-weight: 700;
            color: #ffd166;
            font-size: 0.88em;
        }

        .saved-level-item-meta {
            margin-top: 2px;
            opacity: 0.85;
            font-size: 0.8em;
            word-break: normal;
            white-space: nowrap;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .saved-level-item-icons {
            display: flex;
            flex-wrap: nowrap;
            gap: 4px;
            justify-content: center;
            align-content: center;
            align-items: center;
            width: auto;
            max-width: none;
            min-height: 32px;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: thin;
        }

        .saved-level-item-icon {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.28);
            background: rgba(255,255,255,0.12);
            padding: 2px;
            object-fit: contain;
            object-position: center;
        }

        .saved-level-item-icons-empty {
            text-align: center;
            opacity: 0.7;
            font-size: 0.78em;
            white-space: nowrap;
            width: auto;
            align-self: center;
        }

        .saved-level-item-edit-actions {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 6px;
            height: 100%;
            align-items: center;
        }

        .saved-level-item-edit-actions button {
            width: 100%;
            min-width: 0;
            padding: 6px 8px;
            font-size: 0.78em;
        }

        .saved-level-empty {
            opacity: 0.75;
            font-size: 0.85em;
            line-height: 1.4;
            padding: 10px 8px;
        }

        .saved-level-context-menu {
            position: fixed;
            z-index: 10020;
            display: none;
            min-width: 120px;
            background: rgba(17, 24, 39, 0.96);
            border: 1px solid rgba(255,255,255,0.22);
            border-radius: 8px;
            padding: 4px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.35);
        }

        .saved-level-context-menu.visible {
            display: block;
        }

        .saved-level-context-menu button {
            width: 100%;
            text-align: left;
            background: transparent;
            color: #fff;
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .hotkey-button {
            position: relative;
            padding-left: 44px;
        }

        .hotkey-button::before {
            content: attr(data-shortcut);
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.72em;
            line-height: 1;
            padding: 3px 7px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.35);
            color: #fff;
            opacity: 0.95;
            pointer-events: none;
            letter-spacing: 0.02em;
        }

        .saved-level-context-menu button:hover {
            background: rgba(255,255,255,0.16);
            transform: none;
            box-shadow: none;
        }

        .saved-level-preview {
            position: fixed;
            z-index: 10010;
            display: none;
            min-width: 180px;
            max-width: 320px;
            background: rgba(17, 24, 39, 0.97);
            border: 1px solid rgba(255,255,255,0.24);
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.38);
            pointer-events: none;
        }

        .saved-level-preview.visible {
            display: block;
        }

        .saved-level-preview-header {
            font-size: 0.78em;
            opacity: 0.9;
            margin-bottom: 6px;
            color: #d9e6ff;
        }

        .saved-level-preview-board {
            display: grid;
            gap: 0;
            background: transparent;
            padding: 0;
            border-radius: 6px;
            width: fit-content;
            max-width: 100%;
            --preview-scale: 1;
        }

        .saved-level-preview-cell {
            position: relative;
            width: 14px;
            height: 14px;
            border-radius: 2px;
            background: rgba(255,255,255,0.15);
            overflow: hidden;
        }

        .saved-level-preview-cell.is-empty {
            background: rgba(255,255,255,0.04);
        }

        .saved-level-preview-stack {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .saved-level-preview-stack img,
        .saved-level-preview-obstacle {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: top center;
            pointer-events: none;
            user-select: none;
            backface-visibility: hidden;
            will-change: transform, opacity;
        }

        .saved-level-preview-base {
            z-index: 1;
            transform: scale(1.3);
            transform-origin: top center;
        }

        .saved-level-preview-face {
            z-index: 3;
            transform: scale(1.2);
            transform-origin: top center;
        }

        .saved-level-preview-face-bomb {
            transform: scale(0.8);
            transform-origin: top center;
            object-position: top center;
        }

        .saved-level-preview-attachment {
            z-index: 4;
            transform-origin: top center;
        }

        .saved-level-preview-attachment-fanpai {
            transform: scale(1.3);
        }

        .saved-level-preview-attachment-iceshell {
            transform: translateY(calc(2px * var(--preview-scale))) scale(1.2);
        }

        .saved-level-preview-obstacle {
            object-position: top center;
        }

        .saved-level-preview-obstacle-scale130 {
            transform: translateY(calc(5px * var(--preview-scale))) scale(1.2);
            transform-origin: top center;
        }

        .stats-line {
            text-align: left;
            margin-top: 6px;
            font-size: 0.85em;
            line-height: 1.45;
            opacity: 0.9;
            word-break: break-word;
            white-space: pre-wrap;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
        }

        .stats-item {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 8px;
            padding: 8px 10px;
        }

        .stats-item-title {
            font-size: 0.78em;
            letter-spacing: 0.02em;
            opacity: 0.8;
            color: #b9d7ff;
            margin-bottom: 4px;
        }

        .stats-actions {
            margin-bottom: 8px;
        }

        .stats-actions button {
            width: 100%;
        }

        @media (max-width: 1500px) {
            .main-content {
                grid-template-columns: minmax(360px, 430px) minmax(0, 1fr);
            }

            .board-layout {
                grid-template-columns: 260px minmax(0, 1fr) 280px;
            }
        }

        @media (max-width: 1280px) {
            .main-content {
                grid-template-columns: 1fr;
                height: auto;
            }

            .config-panel {
                height: auto;
                max-height: none;
                overflow: visible;
                padding-right: 0;
            }

            .workspace-panel {
                height: auto;
                min-height: 0;
            }

            .board-layout {
                grid-template-columns: 1fr;
                height: auto;
            }

            .board-side-panel {
                height: auto;
                max-height: none;
                overflow: visible;
            }

            .board-editor-panel {
                height: auto;
                max-height: none;
                overflow: visible;
            }

            .board-container {
                height: 72vh;
            }

        }

        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            .main-content {
                height: auto;
            }

            .cell {
                width: 80px;
                height: 80px;
            }

            .board {
                gap: 1px;
                padding: 5px;
            }

            .controls-row button {
                min-width: 120px;
            }

            .board-top-actions {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }

            .editor-tools {
                grid-template-columns: repeat(4, minmax(0, 1fr));
            }

            .board-bg-control label {
                display: none;
            }

            .board-bg-dropdown {
                width: 78px;
                min-width: 78px;
            }

            .board-bg-dropdown-toggle {
                padding: 5px 6px;
            }

            .board-bg-dropdown-menu {
                width: 176px;
            }

            .board-bg-option {
                grid-template-columns: 48px minmax(0, 1fr);
                gap: 6px;
                padding: 5px;
            }

            .board-bg-option-thumb {
                width: 48px;
                height: 27px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div class="panel config-panel">
                <div class="config-section">
                    <div class="config-title">棋盘规格</div>
                    <div class="config-grid">
                        <div class="config-item">
                            <label>规格：</label>
                            <select id="boardSizeSpec" onchange="handleBoardSizeSpecChange()">
                                <option value="6x8">6×8</option>
                                <option value="8x10">8×10</option>
                                <option value="10x12">10×12</option>
                            </select>
                            <input type="hidden" id="width" value="6">
                            <input type="hidden" id="height" value="8">
                        </div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="config-title">数字配置</div>
                    <div class="config-grid">
                        <div class="config-item">
                            <label>8张同色：</label>
                            <input type="number" id="count8" min="0" max="20" value="0" onchange="calculatePool()">
                        </div>
                        <div class="config-item">
                            <label>6张同色：</label>
                            <input type="number" id="count6" min="0" max="20" value="0" onchange="calculatePool()">
                        </div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="config-title">概率参数 (0-1)</div>
                    <div class="config-grid probability-grid">
                        <div class="config-item">
                            <label>同列/同行同数字概率：</label>
                            <div class="slider-wrap">
                                <input
                                    type="range"
                                    id="sameLie"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value="0.1"
                                    oninput="document.getElementById('sameLieValue').textContent=parseFloat(this.value).toFixed(2);"
                                >
                                <span class="slider-value" id="sameLieValue">0.10</span>
                            </div>
                        </div>
                        <div class="config-item">
                            <label>同位置相同概率：</label>
                            <div class="slider-wrap">
                                <input
                                    type="range"
                                    id="sameNum"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value="0.1"
                                    oninput="document.getElementById('sameNumValue').textContent=parseFloat(this.value).toFixed(2);"
                                >
                                <span class="slider-value" id="sameNumValue">0.10</span>
                            </div>
                        </div>
                        <div class="config-item">
                            <label>相邻列同位置相同概率：</label>
                            <div class="slider-wrap">
                                <input
                                    type="range"
                                    id="xianglinSame"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value="0.1"
                                    oninput="document.getElementById('xianglinSameValue').textContent=parseFloat(this.value).toFixed(2);"
                                >
                                <span class="slider-value" id="xianglinSameValue">0.10</span>
                            </div>
                        </div>
                        <div class="config-item">
                            <label>方向上下重叠控制：</label>
                            <div class="slider-wrap">
                                <input
                                    type="range"
                                    id="directionBothCtrl"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value="0.50"
                                    oninput="document.getElementById('directionBothCtrlValue').textContent=parseFloat(this.value).toFixed(2);"
                                >
                                <span class="slider-value" id="directionBothCtrlValue">0.50</span>
                            </div>
                        </div>
                        <div class="config-item">
                            <label>同色邻近概率（8格）：</label>
                            <div class="slider-wrap">
                                <input
                                    type="range"
                                    id="distanceCtrl"
                                    min="0"
                                    max="1"
                                    step="0.01"
                                    value="0.1"
                                    oninput="document.getElementById('distanceCtrlValue').textContent=parseFloat(this.value).toFixed(2);"
                                >
                                <span class="slider-value" id="distanceCtrlValue">0.10</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="config-section">
                    <div class="config-title">配置组</div>
                    <div class="config-grid" style="grid-template-columns: 1fr;">
                        <div class="config-item">
                            <label>配置名：</label>
                            <input type="text" id="configGroupName" placeholder="输入配置名后保存">
                        </div>
                        <div class="config-item">
                            <label>已保存：</label>
                            <select id="configGroupSelect" onchange="loadSelectedConfigGroup()">
                                <option value="">请选择配置组</option>
                            </select>
                        </div>
                    </div>
                    <div class="controls-row config-group-actions" style="margin-top: 8px;">
                        <button class="btn-primary" onclick="saveCurrentConfigGroup()">保存配置组</button>
                        <button class="btn-secondary" onclick="deleteSelectedConfigGroup()">删除配置组</button>
                        <button class="btn-export" onclick="triggerImportConfigGroups()">读取配置组</button>
                        <button class="btn-primary" onclick="exportConfigToClipboard()">导出参数</button>
                    </div>
                    <input
                        type="file"
                        id="configGroupFileInput"
                        accept=".json,application/json"
                        onchange="handleConfigGroupFileChange(event)"
                        style="display: none;"
                    >
                </div>

                <div class="config-section">
                    <div class="config-title">批量生成</div>
                    <div class="controls-row" style="margin-top: 8px;">
                        <div class="config-item" style="flex: 1; min-width: 180px;">
                            <label>生成数量：</label>
                            <input type="number" id="batchCount" min="1" max="100" value="10">
                        </div>
                        <div class="config-item" style="flex: 1; min-width: 180px;">
                            <label>跑关轮数：</label>
                            <input type="number" id="batchCampaignRounds" min="1" max="100" value="1">
                        </div>
                        <button class="btn-export" id="btnBatchGenerate" onclick="batchGenerate()">导出批量</button>
                        <button class="btn-primary" id="btnBatchRunCampaign"
                            onclick="triggerBatchRunCampaignImport()">跑关导出</button>
                    </div>
                    <input
                        type="file"
                        id="batchRunCampaignFileInput"
                        accept=".json,application/json"
                        onchange="handleBatchRunCampaignFileChange(event)"
                        style="display: none;"
                    >
                </div>

                <div class="error-msg" id="errorMsg" style="display: none;"></div>
            </div>

            <div class="panel workspace-panel">
                <div class="board-layout">
                    <div class="board-editor-panel">
                        <div class="editor-section">
                            <div class="result-title">关卡编辑</div>
                            <div class="editor-board-actions">
                                <button class="btn-generate hotkey-button" data-shortcut="R"
                                    onclick="fillBoard()">生成</button>
                                <button class="btn-primary hotkey-button" data-shortcut="N"
                                    onclick="refreshBoardWithPlaceholder()">刷新棋盘</button>
                                <button class="btn-secondary hotkey-button" data-shortcut="C"
                                    onclick="clearBoard()">清空</button>
                                <button class="btn-primary" onclick="importBoardFromClipboard()">读取阵型</button>
                                <button class="btn-secondary hotkey-button" id="btnSaveCurrentLevel"
                                    data-shortcut="S"
                                    onclick="saveCurrentLevelToList()">保存本关</button>
                                <button class="btn-export" id="btnExportSingle"
                                    onclick="exportToClipboard()">导出当前</button>
                            </div>
                            <div class="editor-tools" id="editorTools"></div>
                            <div class="editor-tip" id="editorTip">
                                左键放置已选元素；右键删除该格全部元素。
                            </div>
                        </div>

                        <div class="stats-section">
                            <div class="result-title">每关统计</div>
                            <div class="stats-actions">
                                <button class="btn-primary" id="btnStepGenerate" onclick="stepGenerateOrNext()">分步生成</button>
                                <button class="btn-secondary" id="btnPlayMode" onclick="togglePlayMode()"
                                    style="margin-top: 8px;">试玩模式</button>
                                <button class="btn-export hotkey-button" data-shortcut="空格"
                                    id="btnSimulatePlay" onclick="simulatePlayGames()"
                                    style="margin-top: 8px;">模拟100局</button>
                            </div>
                            <div class="stats-grid">
                                <div class="stats-item">
                                    <div class="stats-item-title">模拟100局胜率</div>
                                    <div class="stats-line" id="levelStatsSimulation">-</div>
                                </div>
                            </div>
                        </div>

                        <div class="result-section">
                            <div class="result-title">配置结果</div>
                            <div class="result-grid">
                                <div class="result-item">
                                    <div class="result-value" id="result8">0</div>
                                    <div class="result-label">8张种类</div>
                                </div>
                                <div class="result-item">
                                    <div class="result-value" id="result6">0</div>
                                    <div class="result-label">6张种类</div>
                                </div>
                                <div class="result-item">
                                    <div class="result-value" id="result4">0</div>
                                    <div class="result-label">4张种类</div>
                                </div>
                                <div class="result-item">
                                    <div class="result-value" id="result2">0</div>
                                    <div class="result-label">2张种类</div>
                                </div>
                                <div class="result-item">
                                    <div class="result-value" id="resultTotalTypes">0</div>
                                    <div class="result-label">种类数</div>
                                </div>
                                <div class="result-item">
                                    <div class="result-value" id="resultTotalCards">0</div>
                                    <div class="result-label">总卡牌</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="board-container">
                        <div class="board-top-tools">
                            <div class="board-status-row">
                                <div class="info" id="info"></div>
                                <button
                                    type="button"
                                    id="btnPlayRetry"
                                    class="btn-play-retry"
                                    onclick="restartPlayMode()"
                                >重玩</button>
                                <div class="board-bg-control">
                                    <label for="boardBgDropdownToggle">背景</label>
                                    <div
                                        class="board-bg-dropdown"
                                        id="boardBgDropdown"
                                    >
                                        <button
                                            type="button"
                                            id="boardBgDropdownToggle"
                                            class="board-bg-dropdown-toggle"
                                            onclick="toggleBoardBackgroundDropdown(event)"
                                        >
                                            <span id="boardBgDropdownToggleText">背景1</span>
                                        </button>
                                        <div class="board-bg-dropdown-menu" id="boardBgDropdownMenu"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="board-wrapper" id="boardWrapper">
                            <div class="board" id="board"></div>
                        </div>
                    </div>

                    <div class="board-side-panel">
                        <div class="saved-levels-section">
                            <div class="result-title">关卡列表</div>
                            <div class="saved-level-actions">
                                <button class="btn-primary" onclick="triggerImportSavedLevels()">读取</button>
                                <button class="btn-secondary" onclick="saveSavedLevelsToCurrentFile()">保存</button>
                                <button class="btn-export" onclick="exportSavedLevels()">导出</button>
                            </div>
                            <div class="saved-level-list" id="savedLevelList"></div>
                            <input
                                type="file"
                                id="savedLevelFileInput"
                                accept=".txt,.json,text/plain,application/json"
                                onchange="handleSavedLevelFileChange(event)"
                                style="display: none;"
                            >
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="global-interaction-blocker" id="globalInteractionBlocker" aria-hidden="true"></div>
    <div class="saved-level-context-menu" id="savedLevelContextMenu">
        <button type="button" onclick="handleSavedLevelContextAction('edit')">编辑</button>
        <button type="button" onclick="handleSavedLevelContextAction('reorder')">输入序号</button>
        <button type="button" onclick="handleSavedLevelContextAction('delete')">删除</button>
    </div>
    <div class="saved-level-preview" id="savedLevelPreview"></div>

    <script>
        let currentPool = [];
        let filledCells = [];
        let poolCards = [];
        let imageMapping = [];
        let placedCounts = {};
        let stepGenerationState = null;
        let playModeState = null;
        let playDragState = null;
        let suppressPlayModeClickOnce = false;
        let isSimulatingPlayGames = false;
        let isBatchGenerating = false;
        let isBatchCampaignRunning = false;
        let savedLevels = [];
        let savedLevelFileHandle = null;
        let savedLevelSourceFileName = '';
        let savedLevelContextIndex = -1;
        let editingSavedLevelIndex = -1;
        let editingSavedLevelSnapshot = null;
        let simulationWorkerScriptUrl = null;
        let infoMutationObserver = null;
        let selectedEditorTool = 'placeholder';
        let selectedBoardBackgroundIndex = 1;
        let editorBrushState = {
            active: false,
            mode: null,
            lastCellKey: ''
        };
        let savedConfigGroups = [];
        const CONFIG_GROUP_STORAGE_KEY = 'levelmake.configGroups.v1';
        const BOARD_BACKGROUND_MIN_INDEX = 1;
        const BOARD_BACKGROUND_MAX_INDEX = 9;
        const BOARD_SIZE_SPECS = [
            { key: '6x8', width: 6, height: 8, label: '6×8' },
            { key: '8x10', width: 8, height: 10, label: '8×10' },
            { key: '10x12', width: 10, height: 12, label: '10×12' }
        ];
        const BOARD_SIZE_SPEC_KEY_MAP = new Map(
            BOARD_SIZE_SPECS.map((spec) => [spec.key, spec])
        );
        const DEFAULT_BOARD_SIZE_SPEC = '6x8';
        const ROW_BASE_DIRECTIONS = [3, 4, 6, 8];
        const COLUMN_BASE_DIRECTIONS = [0, 1, 2, 5, 7];
        const EMPTY_CELL_ID = 0;
        const PLACEHOLDER_CELL_ID = 499;
        const BOMB_CELL_ID = 99;
        const ATTACHMENT_MULTIPLIER = 1000;
        const ATTACHMENT_FANPAI_ID = 1;
        const ATTACHMENT_ICESHELL_ID = 5;
        const STONE_CELL_ID = 501;
        const WOOD_CELL_ID = 502;
        const LEGACY_MAGNET_CELL_ID = 503;
        const ICE_LEVEL_1_CELL_ID = 504;
        const ICE_LEVEL_2_CELL_ID = 505;
        const ICE_LEVEL_3_CELL_ID = 506;
        const IMMOBILE_OBSTACLE_IDS = new Set([
            STONE_CELL_ID,
            ICE_LEVEL_1_CELL_ID,
            ICE_LEVEL_2_CELL_ID,
            ICE_LEVEL_3_CELL_ID
        ]);
        const OBSTACLE_IDS = new Set([
            STONE_CELL_ID,
            WOOD_CELL_ID,
            ICE_LEVEL_1_CELL_ID,
            ICE_LEVEL_2_CELL_ID,
            ICE_LEVEL_3_CELL_ID
        ]);
        const ATTACHMENT_IDS = new Set([ATTACHMENT_FANPAI_ID, ATTACHMENT_ICESHELL_ID]);
        const LLK_DIRECTION_STEPS = [
            [-1, 0],
            [1, 0],
            [0, -1],
            [0, 1]
        ];
        const PLAY_DRAG_AXIS_LOCK_THRESHOLD = 12;
        const EDITOR_TOOLS = [
            { key: 'placeholder', title: '占位块', idLabel: '499', preview: 'img/base.png' },
            { key: 'attach-fanpai', title: '翻牌', idLabel: '1000', preview: 'img/fanpai.png' },
            { key: 'attach-iceshell', title: '冰壳', idLabel: '5000', preview: 'img/iceshell.png' },
            { key: 'stone', title: '石头', idLabel: '501', preview: 'img/shitou.png' },
            { key: 'wood', title: '木块', idLabel: '502', preview: 'img/mukuai.png' },
            { key: 'ice1', title: '冰块1', idLabel: '504', preview: 'img/bing1.png' },
            { key: 'ice2', title: '冰块2', idLabel: '505', preview: 'img/bing2.png' },
            { key: 'ice3', title: '冰块3', idLabel: '506', preview: 'img/bing3.png' },
            { key: 'bomb', title: '炸弹', idLabel: '99', preview: 'img/zhadan.png' }
        ];
        const EDITOR_BRUSH_TOOL_KEYS = new Set([
            'placeholder',
            'attach-fanpai',
            'attach-iceshell',
            'stone',
            'wood',
            'ice1',
            'ice2',
            'ice3'
        ]);

        function getObstacleImagePath(baseId) {
            const imageMap = {
                [STONE_CELL_ID]: 'img/shitou.png',
                [WOOD_CELL_ID]: 'img/mukuai.png',
                [ICE_LEVEL_1_CELL_ID]: 'img/bing1.png',
                [ICE_LEVEL_2_CELL_ID]: 'img/bing2.png',
                [ICE_LEVEL_3_CELL_ID]: 'img/bing3.png'
            };
            return imageMap[baseId] || '';
        }

        function getAttachmentImagePath(attachmentId) {
            const imageMap = {
                [ATTACHMENT_FANPAI_ID]: 'img/fanpai.png',
                [ATTACHMENT_ICESHELL_ID]: 'img/iceshell.png'
            };
            return imageMap[attachmentId] || '';
        }

        function isEmptyCellId(cellId) {
            return !Number.isInteger(cellId) || cellId <= 0;
        }

        function decodeCellId(cellId) {
            if (isEmptyCellId(cellId)) {
                return {
                    rawId: EMPTY_CELL_ID,
                    baseId: EMPTY_CELL_ID,
                    attachmentId: null,
                    hasAttachment: false
                };
            }

            if (cellId >= ATTACHMENT_MULTIPLIER) {
                const attachmentId = Math.floor(cellId / ATTACHMENT_MULTIPLIER);
                const rawBaseId = cellId % ATTACHMENT_MULTIPLIER;
                const baseId = rawBaseId === LEGACY_MAGNET_CELL_ID ? STONE_CELL_ID : rawBaseId;
                if (ATTACHMENT_IDS.has(attachmentId) && baseId > 0) {
                    return {
                        rawId: cellId,
                        baseId,
                        attachmentId,
                        hasAttachment: true
                    };
                }
            }

            return {
                rawId: cellId,
                baseId: cellId === LEGACY_MAGNET_CELL_ID ? STONE_CELL_ID : cellId,
                attachmentId: null,
                hasAttachment: false
            };
        }

        function encodeAttachedCellId(baseId, attachmentId) {
            if (!Number.isInteger(baseId) || baseId <= 0) return EMPTY_CELL_ID;
            if (!ATTACHMENT_IDS.has(attachmentId)) return baseId;
            return (attachmentId * ATTACHMENT_MULTIPLIER) + baseId;
        }

        function isObstacleBaseId(baseId) {
            return OBSTACLE_IDS.has(baseId);
        }

        function isImmobileObstacleBaseId(baseId) {
            return IMMOBILE_OBSTACLE_IDS.has(baseId);
        }

        function isNormalBaseId(baseId) {
            if (baseId === PLACEHOLDER_CELL_ID) return true;
            return baseId >= 1 && baseId <= 99;
        }

        function isRemovableBaseId(baseId) {
            return isNormalBaseId(baseId);
        }

        function getMatchableBaseId(cellId) {
            const parsed = decodeCellId(cellId);
            if (!isRemovableBaseId(parsed.baseId)) return null;
            if (parsed.hasAttachment) return null;
            return parsed.baseId;
        }

        function isCellClickableInPlay(cellId) {
            const parsed = decodeCellId(cellId);
            if (!isRemovableBaseId(parsed.baseId)) return false;
            return !parsed.hasAttachment;
        }

        function getFillablePlaceholderMeta(cellId) {
            const parsed = decodeCellId(cellId);
            if (parsed.baseId !== PLACEHOLDER_CELL_ID) return null;
            return {
                baseId: parsed.baseId,
                attachmentId: parsed.hasAttachment ? parsed.attachmentId : null
            };
        }

        function getRegenerateTargetMeta(cellId) {
            const parsed = decodeCellId(cellId);
            if (!isRemovableBaseId(parsed.baseId)) return null;
            if (parsed.baseId === BOMB_CELL_ID) return null;
            return {
                baseId: parsed.baseId,
                attachmentId: parsed.hasAttachment ? parsed.attachmentId : null
            };
        }

        function canAttachToCellId(cellId) {
            const parsed = decodeCellId(cellId);
            if (isEmptyCellId(parsed.baseId)) return false;
            if (parsed.hasAttachment) return false;
            if (isObstacleBaseId(parsed.baseId)) return false;
            return isRemovableBaseId(parsed.baseId);
        }

        function getCardCountBaseId(cellId) {
            const parsed = decodeCellId(cellId);
            if (!isRemovableBaseId(parsed.baseId)) return null;
            return parsed.baseId;
        }

        function validateBoardPairLegality(boardData) {
            if (!Array.isArray(boardData)) return { valid: false, message: '棋盘数据无效' };
            const countMap = new Map();
            for (const row of boardData) {
                if (!Array.isArray(row)) continue;
                for (const rawId of row) {
                    const baseId = getCardCountBaseId(rawId);
                    if (baseId === null) continue;
                    countMap.set(baseId, (countMap.get(baseId) || 0) + 1);
                }
            }

            const invalid = [];
            countMap.forEach((count, baseId) => {
                if (count % 2 !== 0) invalid.push(`${baseId}:${count}`);
            });
            if (invalid.length > 0) {
                return {
                    valid: false,
                    message: `存在非成对花色ID（${invalid.join(', ')}）`
                };
            }
            return { valid: true, message: '' };
        }

        function ensureBoardPairLegality(actionName) {
            const legality = validateBoardPairLegality(getBoardData());
            if (legality.valid) return true;
            alert(`${actionName}前校验失败：${legality.message}`);
            return false;
        }

        function isRowBaseDirection(direction) {
            if (ROW_BASE_DIRECTIONS.includes(direction)) return true;
            if (COLUMN_BASE_DIRECTIONS.includes(direction)) return false;
            return false;
        }

        function getLocalBaseDirectionByCell(direction, rowIndex, colIndex, width, height) {
            switch (direction) {
                case 1: return 1;
                case 2: return 2;
                case 3: return 3;
                case 4: return 4;
                case 5:
                    return rowIndex < height / 2 ? 2 : 1;
                case 6:
                    return colIndex < width / 2 ? 4 : 3;
                case 7:
                    return rowIndex < height / 2 ? 1 : 2;
                case 8:
                    return colIndex < width / 2 ? 3 : 4;
                default:
                    return 0;
            }
        }

        function collectDirectionalSideNumbers(rowIndex, colIndex, width, height, localDirection, sideType) {
            const sideNumbers = new Set();
            if (localDirection === 0) return sideNumbers;

            let stepI = 0;
            let stepJ = 0;
            if (localDirection === 1) {
                stepI = sideType === 'top' ? 1 : -1;
            } else if (localDirection === 2) {
                stepI = sideType === 'top' ? -1 : 1;
            } else if (localDirection === 3) {
                stepJ = sideType === 'top' ? 1 : -1;
            } else if (localDirection === 4) {
                stepJ = sideType === 'top' ? -1 : 1;
            }

            let ni = rowIndex + stepI;
            let nj = colIndex + stepJ;
            while (ni >= 0 && ni < height && nj >= 0 && nj < width) {
                const value = filledCells[ni]?.[nj];
                if (Number.isInteger(value) && value > 0) {
                    sideNumbers.add(value);
                }
                ni += stepI;
                nj += stepJ;
            }
            return sideNumbers;
        }

        function shuffleImages() {
            imageMapping = Array.from({length: 34}, (_, i) => i + 1);
            for (let i = imageMapping.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [imageMapping[i], imageMapping[j]] = [imageMapping[j], imageMapping[i]];
            }
        }

        function getImageForNumber(num) {
            const index = (num - 1) % imageMapping.length;
            return imageMapping[index];
        }

        function getEditorToolByKey(toolKey) {
            return EDITOR_TOOLS.find((tool) => tool.key === toolKey) || null;
        }

        function renderEditorTools() {
            const toolsContainer = document.getElementById('editorTools');
            if (!toolsContainer) return;
            toolsContainer.innerHTML = '';
            for (const tool of EDITOR_TOOLS) {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'editor-tool';
                button.dataset.tool = tool.key;
                button.onclick = () => selectEditorTool(tool.key);

                const preview = document.createElement('img');
                preview.className = 'editor-tool-preview';
                preview.src = tool.preview;
                preview.alt = tool.title;

                const title = document.createElement('div');
                title.textContent = tool.title;

                const idLabel = document.createElement('div');
                idLabel.className = 'editor-tool-id';
                idLabel.textContent = `ID:${tool.idLabel}`;

                button.appendChild(preview);
                button.appendChild(title);
                button.appendChild(idLabel);
                toolsContainer.appendChild(button);
            }
            selectEditorTool(selectedEditorTool);
        }

        function selectEditorTool(toolKey) {
            if (!getEditorToolByKey(toolKey)) return;
            selectedEditorTool = toolKey;
            document.querySelectorAll('.editor-tool').forEach((button) => {
                button.classList.toggle('selected', button.dataset.tool === toolKey);
            });
            const tool = getEditorToolByKey(toolKey);
            const editorTip = document.getElementById('editorTip');
            if (editorTip && tool) {
                editorTip.textContent =
                    `已选中：${tool.title}（ID:${tool.idLabel}）。左键放置，右键删除；占位块/障碍/附着支持按住拖动。`;
            }
        }

        function isEditorOperationBlocked() {
            return Boolean(
                (playModeState && playModeState.active) ||
                isSimulatingPlayGames ||
                isBatchCampaignRunning ||
                isBatchGenerating
            );
        }

        function canUseEditorBrushForCurrentTool() {
            return EDITOR_BRUSH_TOOL_KEYS.has(selectedEditorTool);
        }

        function fillEmptyWithPlaceholder() {
            if (!Array.isArray(filledCells) || filledCells.length === 0) return;
            const { width, height } = getCurrentBoardDimensions();
            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    const currentValue = filledCells[row]?.[col] ?? EMPTY_CELL_ID;
                    if (!isEmptyCellId(decodeCellId(currentValue).baseId)) continue;
                    filledCells[row][col] = PLACEHOLDER_CELL_ID;
                    renderCellNumber(row, col, PLACEHOLDER_CELL_ID);
                }
            }
            resetLevelStats();
        }

        function refreshBoardWithPlaceholder() {
            generateBoard();
            fillEmptyWithPlaceholder();
        }

        function setCellIdAtPosition(row, col, cellId) {
            if (!Array.isArray(filledCells[row])) return;
            filledCells[row][col] = cellId;
            renderCellNumber(row, col, cellId);
        }

        function applyEditorToolOnCell(row, col) {
            if (isEditorOperationBlocked()) return;
            const currentValue = filledCells[row]?.[col] ?? EMPTY_CELL_ID;
            const parsed = decodeCellId(currentValue);

            switch (selectedEditorTool) {
                case 'placeholder':
                    setCellIdAtPosition(row, col, PLACEHOLDER_CELL_ID);
                    return;
                case 'bomb':
                    setCellIdAtPosition(row, col, BOMB_CELL_ID);
                    return;
                case 'stone':
                    setCellIdAtPosition(row, col, STONE_CELL_ID);
                    return;
                case 'wood':
                    setCellIdAtPosition(row, col, WOOD_CELL_ID);
                    return;
                case 'ice1':
                    setCellIdAtPosition(row, col, ICE_LEVEL_1_CELL_ID);
                    return;
                case 'ice2':
                    setCellIdAtPosition(row, col, ICE_LEVEL_2_CELL_ID);
                    return;
                case 'ice3':
                    setCellIdAtPosition(row, col, ICE_LEVEL_3_CELL_ID);
                    return;
                case 'attach-fanpai':
                    if (!canAttachToCellId(currentValue)) return;
                    setCellIdAtPosition(
                        row,
                        col,
                        encodeAttachedCellId(parsed.baseId, ATTACHMENT_FANPAI_ID)
                    );
                    return;
                case 'attach-iceshell':
                    if (!canAttachToCellId(currentValue)) return;
                    setCellIdAtPosition(
                        row,
                        col,
                        encodeAttachedCellId(parsed.baseId, ATTACHMENT_ICESHELL_ID)
                    );
                    return;
                default:
                    return;
            }
        }

        function clearCellByRightClick(row, col) {
            if (isEditorOperationBlocked()) return;
            setCellIdAtPosition(row, col, EMPTY_CELL_ID);
        }

        function getProbabilityValue(elementId, defaultValue = 0.1) {
            const element = document.getElementById(elementId);
            if (!element) return defaultValue;
            const parsed = parseFloat(element.value);
            if (!Number.isFinite(parsed)) return defaultValue;
            return Math.max(0, Math.min(1, parsed));
        }

        function getCurrentDirectionValue() {
            return 0;
        }

        function getBoardSizeSpecByKey(specKey) {
            return BOARD_SIZE_SPEC_KEY_MAP.get(String(specKey)) || null;
        }

        function normalizeBoardSizeSpecToken(rawValue) {
            return String(rawValue || '')
                .toLowerCase()
                .replace(/\s+/g, '')
                .replace(/×/g, 'x')
                .replace(/\*/g, 'x');
        }

        function normalizeBoardSizeSpecValue(rawValue, fallback = DEFAULT_BOARD_SIZE_SPEC) {
            const fallbackEntry = getBoardSizeSpecByKey(fallback);
            const fallbackKey = fallbackEntry ? fallbackEntry.key : DEFAULT_BOARD_SIZE_SPEC;

            const normalizedToken = normalizeBoardSizeSpecToken(rawValue);
            if (BOARD_SIZE_SPEC_KEY_MAP.has(normalizedToken)) return normalizedToken;

            if (rawValue && typeof rawValue === 'object') {
                const keyFromObject = resolveBoardSizeSpecFromDimensions(
                    rawValue.width,
                    rawValue.height,
                    fallbackKey
                );
                if (BOARD_SIZE_SPEC_KEY_MAP.has(keyFromObject)) return keyFromObject;
            }

            return fallbackKey;
        }

        function isSupportedBoardSize(widthValue, heightValue) {
            const width = Number(widthValue);
            const height = Number(heightValue);
            if (!Number.isFinite(width) || !Number.isFinite(height)) return false;
            const roundedWidth = Math.round(width);
            const roundedHeight = Math.round(height);
            return BOARD_SIZE_SPECS.some(
                (spec) => spec.width === roundedWidth && spec.height === roundedHeight
            );
        }

        function resolveBoardSizeSpecFromDimensions(
            widthValue,
            heightValue,
            fallback = DEFAULT_BOARD_SIZE_SPEC
        ) {
            const width = Number(widthValue);
            const height = Number(heightValue);
            if (Number.isFinite(width) && Number.isFinite(height)) {
                const widthRounded = Math.round(width);
                const heightRounded = Math.round(height);
                for (const spec of BOARD_SIZE_SPECS) {
                    if (spec.width === widthRounded && spec.height === heightRounded) {
                        return spec.key;
                    }
                }
            }

            const selector = document.getElementById('boardSizeSpec');
            if (selector) {
                const selected = normalizeBoardSizeSpecValue(selector.value, fallback);
                if (BOARD_SIZE_SPEC_KEY_MAP.has(selected)) return selected;
            }

            const fallbackEntry = getBoardSizeSpecByKey(fallback);
            return fallbackEntry ? fallbackEntry.key : DEFAULT_BOARD_SIZE_SPEC;
        }

        function syncBoardSizeDom(specValue) {
            const safeSpec = normalizeBoardSizeSpecValue(specValue, DEFAULT_BOARD_SIZE_SPEC);
            const specEntry = getBoardSizeSpecByKey(safeSpec) ||
                getBoardSizeSpecByKey(DEFAULT_BOARD_SIZE_SPEC);
            if (!specEntry) return DEFAULT_BOARD_SIZE_SPEC;
            const selector = document.getElementById('boardSizeSpec');
            if (selector) selector.value = String(specEntry.key);
            const widthInput = document.getElementById('width');
            if (widthInput) widthInput.value = String(specEntry.width);
            const heightInput = document.getElementById('height');
            if (heightInput) heightInput.value = String(specEntry.height);
            return specEntry.key;
        }

        function getCurrentBoardSizeSpec() {
            const widthValue = parseInt(document.getElementById('width')?.value, 10);
            const heightValue = parseInt(document.getElementById('height')?.value, 10);
            const resolvedSpec = resolveBoardSizeSpecFromDimensions(widthValue, heightValue);
            return syncBoardSizeDom(resolvedSpec);
        }

        function getCurrentBoardDimensions() {
            const specKey = getCurrentBoardSizeSpec();
            const specEntry = getBoardSizeSpecByKey(specKey) ||
                getBoardSizeSpecByKey(DEFAULT_BOARD_SIZE_SPEC);
            if (!specEntry) return { width: 6, height: 8 };
            return { width: specEntry.width, height: specEntry.height };
        }

        function setBoardSizeSpec(specValue, options = {}) {
            const safeSpec = syncBoardSizeDom(specValue);
            if (options.refreshPool !== false) calculatePool();
            if (options.refreshInfo) setDefaultInfoText();
            return safeSpec;
        }

        function handleBoardSizeSpecChange() {
            const selector = document.getElementById('boardSizeSpec');
            const selected = selector ? selector.value : DEFAULT_BOARD_SIZE_SPEC;
            setBoardSizeSpec(selected, { refreshPool: true, refreshInfo: true });
        }

        function getCurrentConfigSnapshot() {
            const { width, height } = getCurrentBoardDimensions();
            return {
                width,
                height,
                count8: parseInt(document.getElementById('count8')?.value, 10) || 0,
                count6: parseInt(document.getElementById('count6')?.value, 10) || 0,
                sameLie: getProbabilityValue('sameLie', 0.1),
                sameNum: getProbabilityValue('sameNum', 0.1),
                xianglinSame: getProbabilityValue('xianglinSame', 0.1),
                batchCount: parseInt(document.getElementById('batchCount')?.value, 10) || 10,
                batchCampaignRounds:
                    parseInt(document.getElementById('batchCampaignRounds')?.value, 10) || 1,
                distanceCtrl: getProbabilityValue('distanceCtrl', 0.1)
            };
        }

        function setSliderControlValue(sliderId, valueLabelId, rawValue, decimals = 2) {
            const slider = document.getElementById(sliderId);
            if (slider) slider.value = String(rawValue);
            const valueLabel = document.getElementById(valueLabelId);
            if (!valueLabel) return;
            if (decimals <= 0) {
                valueLabel.textContent = String(parseInt(String(rawValue), 10));
                return;
            }
            const numericValue = Number(rawValue);
            if (!Number.isFinite(numericValue)) {
                valueLabel.textContent = '0.00';
                return;
            }
            valueLabel.textContent = numericValue.toFixed(decimals);
        }

        function applyConfigSnapshot(config) {
            if (!config || typeof config !== 'object') return;
            const clamp = (value, min, max) => Math.min(max, Math.max(min, value));

            const sizeSpec = resolveBoardSizeSpecFromDimensions(config.width, config.height);
            const count8 = Math.round(clamp(
                Number.isFinite(Number(config.count8)) ? Number(config.count8) : 0,
                0,
                20
            ));
            const count6 = Math.round(clamp(
                Number.isFinite(Number(config.count6)) ? Number(config.count6) : 0,
                0,
                20
            ));
            const sameLie = clamp(
                Number.isFinite(Number(config.sameLie)) ? Number(config.sameLie) : 0.1,
                0,
                1
            );
            const sameNum = clamp(
                Number.isFinite(Number(config.sameNum)) ? Number(config.sameNum) : 0.1,
                0,
                1
            );
            const xianglinSame = Number.isFinite(Number(config.xianglinSame))
                ? Number(config.xianglinSame)
                : 0.1;
            const distanceCtrl = clamp(
                Number.isFinite(Number(config.distanceCtrl)) ? Number(config.distanceCtrl) : 0.1,
                0,
                1
            );
            const batchCount = Math.round(clamp(
                Number.isFinite(Number(config.batchCount)) ? Number(config.batchCount) : 10,
                1,
                100
            ));
            const batchCampaignRounds = Math.round(clamp(
                Number.isFinite(Number(config.batchCampaignRounds))
                    ? Number(config.batchCampaignRounds)
                    : 1,
                1,
                100
            ));

            if (playModeState && playModeState.active) {
                exitPlayMode({ restoreBoard: true, silent: true });
            }

            setBoardSizeSpec(sizeSpec, { refreshPool: false, refreshInfo: false });
            setSliderControlValue('sameLie', 'sameLieValue', sameLie, 2);
            setSliderControlValue('sameNum', 'sameNumValue', sameNum, 2);
            setSliderControlValue('xianglinSame', 'xianglinSameValue', clamp(xianglinSame, 0, 1), 2);
            setSliderControlValue('distanceCtrl', 'distanceCtrlValue', distanceCtrl, 2);

            const count8Input = document.getElementById('count8');
            if (count8Input) count8Input.value = String(count8);
            const count6Input = document.getElementById('count6');
            if (count6Input) count6Input.value = String(count6);
            const batchCountInput = document.getElementById('batchCount');
            if (batchCountInput) batchCountInput.value = String(batchCount);
            const batchCampaignRoundsInput = document.getElementById('batchCampaignRounds');
            if (batchCampaignRoundsInput) {
                batchCampaignRoundsInput.value = String(batchCampaignRounds);
            }

            calculatePool();
            setDefaultInfoText();
        }

        function buildDefaultConfigName(config) {
            return `${config.width}x${config.height}`;
        }

        function persistConfigGroups() {
            try {
                localStorage.setItem(CONFIG_GROUP_STORAGE_KEY, JSON.stringify(savedConfigGroups));
            } catch (error) {
                console.error('Failed to persist config groups:', error);
            }
        }

        function renderConfigGroupSelect(selectedName = '') {
            const select = document.getElementById('configGroupSelect');
            if (!select) return;

            const targetName = selectedName || select.value || '';
            select.innerHTML = '<option value="">请选择配置组</option>';

            for (const group of savedConfigGroups) {
                const option = document.createElement('option');
                option.value = group.name;
                option.textContent = group.name;
                select.appendChild(option);
            }

            if (targetName && savedConfigGroups.some(group => group.name === targetName)) {
                select.value = targetName;
            } else {
                select.value = '';
            }
        }

        function loadConfigGroupsFromStorage() {
            try {
                const rawValue = localStorage.getItem(CONFIG_GROUP_STORAGE_KEY);
                if (!rawValue) {
                    savedConfigGroups = [];
                    renderConfigGroupSelect();
                    return;
                }
                const parsed = JSON.parse(rawValue);
                if (!Array.isArray(parsed)) {
                    savedConfigGroups = [];
                    renderConfigGroupSelect();
                    return;
                }
                savedConfigGroups = parsed.filter((item) => {
                    return item && typeof item.name === 'string' && item.config;
                });
                renderConfigGroupSelect();
            } catch (error) {
                console.error('Failed to load config groups:', error);
                savedConfigGroups = [];
                renderConfigGroupSelect();
            }
        }

        function saveCurrentConfigGroup() {
            const nameInput = document.getElementById('configGroupName');
            const currentConfig = getCurrentConfigSnapshot();
            const typedName = (nameInput?.value || '').trim();
            const groupName = typedName || buildDefaultConfigName(currentConfig);

            const existingIndex = savedConfigGroups.findIndex(group => group.name === groupName);
            const configGroup = { name: groupName, config: currentConfig };
            const overwritten = existingIndex >= 0;
            if (overwritten) {
                savedConfigGroups[existingIndex] = configGroup;
            } else {
                savedConfigGroups.push(configGroup);
            }

            persistConfigGroups();
            renderConfigGroupSelect(groupName);
            if (nameInput) nameInput.value = groupName;

            const info = document.getElementById('info');
            if (info) {
                info.textContent = overwritten
                    ? `配置组已覆盖：${groupName}`
                    : `配置组已保存：${groupName}`;
            }
        }

        function loadSelectedConfigGroup() {
            const select = document.getElementById('configGroupSelect');
            const nameInput = document.getElementById('configGroupName');
            const selectedName = select?.value || '';
            if (!selectedName) return;

            const selectedGroup = savedConfigGroups.find(group => group.name === selectedName);
            if (!selectedGroup) return;

            applyConfigSnapshot(selectedGroup.config);
            if (nameInput) nameInput.value = selectedGroup.name;

            const info = document.getElementById('info');
            if (info) info.textContent = `已加载配置组：${selectedGroup.name}`;
        }

        function deleteSelectedConfigGroup() {
            const select = document.getElementById('configGroupSelect');
            const nameInput = document.getElementById('configGroupName');
            const selectedName = select?.value || '';
            if (!selectedName) {
                alert('请先在下拉列表中选择要删除的配置组。');
                return;
            }

            savedConfigGroups = savedConfigGroups.filter(group => group.name !== selectedName);
            persistConfigGroups();
            renderConfigGroupSelect();

            if (nameInput && nameInput.value.trim() === selectedName) {
                nameInput.value = '';
            }

            const info = document.getElementById('info');
            if (info) info.textContent = `已删除配置组：${selectedName}`;
        }

        function triggerImportConfigGroups() {
            const fileInput = document.getElementById('configGroupFileInput');
            if (!fileInput) return;
            fileInput.value = '';
            fileInput.click();
        }

        function buildImportedConfigGroupName(item, index, usedNames) {
            const orderValue = Number(item?.['序号']);
            const rawBaseName = Number.isFinite(orderValue)
                ? `序号${Math.round(orderValue)}`
                : `配置${index + 1}`;
            let name = rawBaseName;
            let suffix = 2;
            while (usedNames.has(name)) {
                name = `${rawBaseName}_${suffix}`;
                suffix++;
            }
            usedNames.add(name);
            return name;
        }

        function mapImportedConfigItem(item) {
            const toNumber = (value, fallback) => {
                const numberValue = Number(value);
                return Number.isFinite(numberValue) ? numberValue : fallback;
            };
            const defaultSpec = getBoardSizeSpecByKey(DEFAULT_BOARD_SIZE_SPEC) || {
                width: 6,
                height: 8
            };
            const importedWidth = toNumber(item?.['宽度'], defaultSpec.width);
            const importedHeight = toNumber(item?.['高度'], defaultSpec.height);
            return {
                width: importedWidth,
                height: importedHeight,
                count8: toNumber(item?.['8张同色'], 0),
                count6: toNumber(item?.['6张同色'], 0),
                sameLie: toNumber(item?.['同列/同行同数字概率'], 0.1),
                sameNum: toNumber(item?.['同位置相同概率'], 0.1),
                xianglinSame: toNumber(item?.['相邻列同位置相同概率'], 0.1),
                batchCount: 10,
                batchCampaignRounds: toNumber(item?.['跑关轮数'] ?? item?.['campaignRounds'], 1),
                distanceCtrl: toNumber(
                    item?.['距离参数'] ?? item?.['同色邻近概率（8格）'] ?? item?.['同色邻近概率'],
                    0.1
                )
            };
        }

        function importConfigGroupsFromJsonContent(jsonText) {
            let parsed;
            try {
                parsed = JSON.parse(jsonText);
            } catch (error) {
                throw new Error('JSON格式错误，无法解析。');
            }
            if (!Array.isArray(parsed)) {
                throw new Error('JSON根节点必须是数组。');
            }

            const usedNames = new Set();
            const importedGroups = [];
            for (let index = 0; index < parsed.length; index++) {
                const item = parsed[index];
                if (!item || typeof item !== 'object') continue;
                const groupName = buildImportedConfigGroupName(item, index, usedNames);
                importedGroups.push({
                    name: groupName,
                    config: mapImportedConfigItem(item)
                });
            }

            if (importedGroups.length === 0) {
                throw new Error('JSON中没有可用的配置数据。');
            }

            savedConfigGroups = importedGroups;
            persistConfigGroups();
            renderConfigGroupSelect();

            const nameInput = document.getElementById('configGroupName');
            if (nameInput) nameInput.value = '';

            const info = document.getElementById('info');
            if (info) info.textContent = `已导入配置组：${importedGroups.length} 条（已覆盖本地配置组）`;
        }

        function handleConfigGroupFileChange(event) {
            const file = event?.target?.files?.[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const content = typeof reader.result === 'string' ? reader.result : '';
                    importConfigGroupsFromJsonContent(content);
                } catch (error) {
                    console.error('Failed to import config groups:', error);
                    alert(error.message || '导入失败，请检查JSON格式。');
                }
            };
            reader.onerror = () => {
                console.error('Failed to read config group file:', reader.error);
                alert('读取文件失败，请重试。');
            };
            reader.readAsText(file, 'utf-8');
        }

        function cloneBoardData(boardData) {
            if (!Array.isArray(boardData)) return [];
            return boardData.map((row) => Array.isArray(row) ? [...row] : []);
        }

        function hasFilledCells(boardData) {
            if (!Array.isArray(boardData)) return false;
            for (const row of boardData) {
                if (!Array.isArray(row)) continue;
                for (const value of row) {
                    if (Number.isInteger(value) && value > 0) return true;
                }
            }
            return false;
        }

        function detectInfoMessageType(text) {
            const content = typeof text === 'string' ? text : '';
            if (!content) return 'default';
            if (
                content.includes('失败') ||
                content.includes('错误') ||
                content.includes('无效') ||
                content.includes('未找到')
            ) {
                return 'error';
            }
            if (
                content.includes('进行中') ||
                content.includes('模拟中') ||
                content.includes('导出中') ||
                content.includes('跑关中') ||
                content.includes('%')
            ) {
                return 'progress';
            }
            if (content.includes('试玩模式')) {
                return 'mode';
            }
            if (
                content.includes('请先') ||
                content.includes('请稍后') ||
                content.includes('提示')
            ) {
                return 'warning';
            }
            if (
                content.includes('已') ||
                content.includes('完成') ||
                content.includes('成功') ||
                content.includes('保存') ||
                content.includes('读取') ||
                content.includes('导入') ||
                content.includes('导出')
            ) {
                return 'success';
            }
            return 'default';
        }

        function applyInfoTypeClass(type = 'default') {
            const info = document.getElementById('info');
            if (!info) return;
            info.classList.remove(
                'info-default',
                'info-success',
                'info-progress',
                'info-mode',
                'info-warning',
                'info-error'
            );
            info.classList.add(`info-${type}`);
        }

        function normalizeBoardBackgroundIndex(backgroundIndex) {
            const parsed = Number(backgroundIndex);
            if (!Number.isFinite(parsed)) return BOARD_BACKGROUND_MIN_INDEX;
            return Math.max(
                BOARD_BACKGROUND_MIN_INDEX,
                Math.min(BOARD_BACKGROUND_MAX_INDEX, Math.round(parsed))
            );
        }

        function getBoardBackgroundPath(backgroundIndex) {
            const safeIndex = normalizeBoardBackgroundIndex(backgroundIndex);
            return `img/bg/bg_${safeIndex}.png`;
        }

        function applyBoardBackground(backgroundIndex) {
            const safeIndex = normalizeBoardBackgroundIndex(backgroundIndex);
            selectedBoardBackgroundIndex = safeIndex;

            const boardContainer = document.querySelector('.board-container');
            if (boardContainer) {
                boardContainer.style.setProperty(
                    '--board-bg-image',
                    `url('${getBoardBackgroundPath(safeIndex)}')`
                );
            }

            updateBoardBackgroundDropdownSelection();
        }

        function updateBoardBackgroundDropdownSelection() {
            const safeIndex = normalizeBoardBackgroundIndex(selectedBoardBackgroundIndex);
            const toggleText = document.getElementById('boardBgDropdownToggleText');
            if (toggleText) {
                toggleText.textContent = `背景${safeIndex}`;
            }
            const menu = document.getElementById('boardBgDropdownMenu');
            if (!menu) return;
            menu.querySelectorAll('.board-bg-option').forEach((button) => {
                const optionIndex = normalizeBoardBackgroundIndex(button.dataset.index);
                button.classList.toggle('selected', optionIndex === safeIndex);
            });
        }

        function renderBoardBackgroundDropdown() {
            const menu = document.getElementById('boardBgDropdownMenu');
            if (!menu) return;
            menu.innerHTML = '';
            for (
                let backgroundIndex = BOARD_BACKGROUND_MIN_INDEX;
                backgroundIndex <= BOARD_BACKGROUND_MAX_INDEX;
                backgroundIndex++
            ) {
                const option = document.createElement('button');
                option.type = 'button';
                option.className = 'board-bg-option';
                option.dataset.index = String(backgroundIndex);
                option.onclick = (event) => {
                    event.stopPropagation();
                    selectBoardBackgroundFromDropdown(backgroundIndex);
                };

                const thumbWrap = document.createElement('span');
                thumbWrap.className = 'board-bg-option-thumb';
                const thumbImage = document.createElement('img');
                thumbImage.src = getBoardBackgroundPath(backgroundIndex);
                thumbImage.alt = `背景${backgroundIndex}`;
                thumbWrap.appendChild(thumbImage);

                const title = document.createElement('span');
                title.className = 'board-bg-option-title';
                title.textContent = `背景${backgroundIndex}`;

                option.appendChild(thumbWrap);
                option.appendChild(title);
                menu.appendChild(option);
            }
            updateBoardBackgroundDropdownSelection();
        }

        function openBoardBackgroundDropdown() {
            const dropdown = document.getElementById('boardBgDropdown');
            if (!dropdown) return;
            dropdown.classList.add('open');
        }

        function closeBoardBackgroundDropdown() {
            const dropdown = document.getElementById('boardBgDropdown');
            if (!dropdown) return;
            dropdown.classList.remove('open');
        }

        function toggleBoardBackgroundDropdown(event) {
            if (event) event.stopPropagation();
            const dropdown = document.getElementById('boardBgDropdown');
            if (!dropdown) return;
            if (!dropdown.classList.contains('open')) {
                openBoardBackgroundDropdown();
            }
        }

        function selectBoardBackgroundFromDropdown(backgroundIndex) {
            applyBoardBackground(backgroundIndex);
        }

        function refreshInfoTypeByCurrentText() {
            const info = document.getElementById('info');
            if (!info) return;
            applyInfoTypeClass(detectInfoMessageType(info.textContent || ''));
        }

        function setInfoText(text = '') {
            const info = document.getElementById('info');
            if (!info) return;
            info.textContent = text;
            refreshInfoTypeByCurrentText();
        }

        function initInfoMutationObserver() {
            const info = document.getElementById('info');
            if (!info || infoMutationObserver) return;
            infoMutationObserver = new MutationObserver(() => {
                refreshInfoTypeByCurrentText();
            });
            infoMutationObserver.observe(info, {
                childList: true,
                characterData: true,
                subtree: true
            });
            refreshInfoTypeByCurrentText();
        }

        function setDefaultInfoText() {
            const { width, height } = getCurrentBoardDimensions();
            if (width > 0 && height > 0) {
                setInfoText(`棋盘: ${width}×${height} = ${width * height} 格`);
            } else {
                setInfoText('');
            }
        }

        function updatePlayModeButton() {
            const playButton = document.getElementById('btnPlayMode');
            if (!playButton) return;
            playButton.textContent = (playModeState && playModeState.active) ? '退出试玩' : '试玩模式';
        }

        function updatePlayRetryButton(visible = false) {
            const retryButton = document.getElementById('btnPlayRetry');
            if (!retryButton) return;
            retryButton.style.display = visible ? 'inline-flex' : 'none';
            retryButton.disabled = !visible;
        }

        function markPlayModeFailed() {
            if (!playModeState || !playModeState.active) return;
            cancelPlayDrag(true);
            suppressPlayModeClickOnce = false;
            clearPlaySelectionVisual();
            clearPlayLinkPath();
            playModeState.failed = true;
            playModeState.isResolving = false;
            setInfoText('试玩模式：失败（无可消除配对）');
            updatePlayRetryButton(true);
        }

        function checkAndHandlePlayFailure(boardData) {
            if (!playModeState || !playModeState.active) return false;
            const sourceBoard = Array.isArray(boardData) ? boardData : playModeState.boardData;
            if (!Array.isArray(sourceBoard)) return false;
            if (isPlayBoardCleared(sourceBoard)) return false;
            if (hasAnyPlayableActionForBoard(sourceBoard)) return false;
            markPlayModeFailed();
            return true;
        }

        function restartPlayMode() {
            if (!playModeState || !playModeState.active) {
                enterPlayMode();
                return;
            }
            if (!Array.isArray(playModeState.originalBoard)) return;
            const board = document.getElementById('board');
            if (board) board.classList.remove('play-shifting');
            cancelPlayDrag(true);
            suppressPlayModeClickOnce = false;
            clearPlaySelectionVisual();
            clearPlayLinkPath();
            playModeState.boardData = cloneBoardData(playModeState.originalBoard);
            playModeState.tokenBoard = createTokenBoardFromBoard(playModeState.originalBoard);
            playModeState.selected = null;
            playModeState.isResolving = false;
            playModeState.failed = false;
            playModeState.clearedPairs = 0;
            syncBoardDisplayWithoutTransition(playModeState.boardData);
            updatePlayRetryButton(false);
            setInfoText('试玩模式：已重玩，请点击牌或拖动连片后松手配对');
        }

        function clearPlaySelectionVisual() {
            if (!playModeState || !playModeState.selected) return;
            const { row, col } = playModeState.selected;
            const selectedCell = document.getElementById(`cell-${row}-${col}`);
            if (selectedCell) {
                selectedCell.classList.remove('play-selected');
                selectedCell.classList.remove('play-clearing');
            }
            playModeState.selected = null;
        }

        function setPlaySelection(row, col) {
            if (!playModeState) return;
            clearPlaySelectionVisual();
            const selectedCell = document.getElementById(`cell-${row}-${col}`);
            if (selectedCell) selectedCell.classList.add('play-selected');
            playModeState.selected = { row, col };
        }

        function waitForMs(durationMs) {
            return new Promise((resolve) => {
                setTimeout(resolve, durationMs);
            });
        }

        function createTokenBoardFromBoard(boardData) {
            if (!Array.isArray(boardData)) return [];
            let nextToken = 1;
            return boardData.map((row) => {
                if (!Array.isArray(row)) return [];
                return row.map((value) => {
                    if (!Number.isInteger(value) || value <= 0) return null;
                    const token = nextToken;
                    nextToken++;
                    return token;
                });
            });
        }

        function getCellStepDistance() {
            const fallback = { stepX: 151, stepY: 151 };
            const originCell = document.getElementById('cell-0-0');
            if (!originCell) return fallback;

            const rightCell = document.getElementById('cell-0-1');
            const downCell = document.getElementById('cell-1-0');
            let stepX = rightCell
                ? Math.abs((rightCell.offsetLeft || 0) - (originCell.offsetLeft || 0))
                : 0;
            let stepY = downCell
                ? Math.abs((downCell.offsetTop || 0) - (originCell.offsetTop || 0))
                : 0;

            if (stepX <= 0 || stepY <= 0) {
                const originRect = originCell.getBoundingClientRect();
                if (stepX <= 0 && rightCell) {
                    stepX = Math.abs(rightCell.getBoundingClientRect().left - originRect.left);
                }
                if (stepY <= 0 && downCell) {
                    stepY = Math.abs(downCell.getBoundingClientRect().top - originRect.top);
                }
            }

            return {
                stepX: stepX > 0 ? stepX : fallback.stepX,
                stepY: stepY > 0 ? stepY : fallback.stepY
            };
        }

        function getBoardRenderScale() {
            const board = document.getElementById('board');
            if (!board) return 1;
            const rect = board.getBoundingClientRect();
            const width = board.offsetWidth || rect.width;
            if (!(width > 0)) return 1;
            const scale = rect.width / width;
            if (!Number.isFinite(scale) || scale <= 0) return 1;
            return scale;
        }

        function collectShiftedCells(beforeTokenBoard, afterTokenBoard) {
            const movedCells = [];
            if (!Array.isArray(beforeTokenBoard) || !Array.isArray(afterTokenBoard)) {
                return movedCells;
            }

            const sourcePositionsByToken = new Map();
            const beforeRows = beforeTokenBoard.length;
            for (let row = 0; row < beforeRows; row++) {
                const cols = beforeTokenBoard[row]?.length || 0;
                for (let col = 0; col < cols; col++) {
                    const token = beforeTokenBoard[row]?.[col];
                    if (!Number.isInteger(token) || token <= 0) continue;
                    sourcePositionsByToken.set(token, { row, col });
                }
            }

            const afterRows = afterTokenBoard.length;
            for (let row = 0; row < afterRows; row++) {
                const cols = afterTokenBoard[row]?.length || 0;
                for (let col = 0; col < cols; col++) {
                    const token = afterTokenBoard[row]?.[col];
                    if (!Number.isInteger(token) || token <= 0) continue;
                    const source = sourcePositionsByToken.get(token);
                    if (!source) continue;
                    if (source.row === row && source.col === col) continue;
                    movedCells.push({
                        row,
                        col,
                        deltaRow: source.row - row,
                        deltaCol: source.col - col
                    });
                }
            }

            return movedCells;
        }

        async function animateBoardShift(movedCells = []) {
            const SHIFT_ANIMATION_MS = 150;
            const board = document.getElementById('board');
            if (!board) return;
            if (!Array.isArray(movedCells) || movedCells.length === 0) return;

            const { stepX, stepY } = getCellStepDistance();
            board.classList.add('play-shifting');
            const animatedCells = [];
            for (const position of movedCells) {
                const cell = document.getElementById(`cell-${position.row}-${position.col}`);
                if (!cell || !cell.classList.contains('filled')) continue;
                const translateX = (position.deltaCol || 0) * stepX;
                const translateY = (position.deltaRow || 0) * stepY;
                cell.style.setProperty('--shift-start-x', `${translateX}px`);
                cell.style.setProperty('--shift-start-y', `${translateY}px`);
                cell.classList.remove('play-shift-anim');
                void cell.offsetWidth;
                cell.classList.add('play-shift-anim');
                animatedCells.push(cell);
            }

            await waitForMs(SHIFT_ANIMATION_MS);
            for (const cell of animatedCells) {
                cell.classList.remove('play-shift-anim');
                cell.style.removeProperty('--shift-start-x');
                cell.style.removeProperty('--shift-start-y');
            }
            board.classList.remove('play-shifting');
        }

        function syncBoardDisplayByData(boardData) {
            if (!Array.isArray(boardData)) return;
            for (let i = 0; i < boardData.length; i++) {
                for (let j = 0; j < boardData[i].length; j++) {
                    renderCellNumber(i, j, boardData[i][j]);
                }
            }
        }

        function syncBoardDisplayWithoutTransition(boardData) {
            const board = document.getElementById('board');
            if (board) board.classList.add('play-no-transition');
            syncBoardDisplayByData(boardData);
            if (board) {
                void board.offsetWidth;
                board.classList.remove('play-no-transition');
            }
        }

        function getCellPositionByElement(cellElement) {
            if (!cellElement || !cellElement.id) return null;
            const idMatch = cellElement.id.match(/^cell-(\d+)-(\d+)$/);
            if (!idMatch) return null;
            return {
                row: parseInt(idMatch[1], 10),
                col: parseInt(idMatch[2], 10)
            };
        }

        function getStraightMatchCandidatesForCell(boardData, row, col) {
            if (!Array.isArray(boardData) || boardData.length === 0) return [];
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width === 0) return [];
            if (row < 0 || row >= height || col < 0 || col >= width) return [];

            const currentBaseId = getMatchableBaseId(boardData[row]?.[col]);
            if (currentBaseId === null) return [];

            const candidates = [];
            const directions = [
                [-1, 0],
                [1, 0],
                [0, -1],
                [0, 1]
            ];

            for (const [dr, dc] of directions) {
                let distance = 1;
                let nextRow = row + dr;
                let nextCol = col + dc;
                while (
                    nextRow >= 0 &&
                    nextRow < height &&
                    nextCol >= 0 &&
                    nextCol < width
                ) {
                    const nextValue = boardData[nextRow]?.[nextCol] ?? EMPTY_CELL_ID;
                    const nextParsed = decodeCellId(nextValue);
                    if (isEmptyCellId(nextParsed.baseId)) {
                        distance++;
                        nextRow += dr;
                        nextCol += dc;
                        continue;
                    }
                    const nextBaseId = getMatchableBaseId(nextValue);
                    if (nextBaseId === currentBaseId) {
                        candidates.push({
                            row: nextRow,
                            col: nextCol,
                            distance
                        });
                    }
                    break;
                }
            }

            candidates.sort((left, right) => {
                if (left.distance !== right.distance) {
                    return left.distance - right.distance;
                }
                if (left.row !== right.row) return left.row - right.row;
                return left.col - right.col;
            });
            return candidates;
        }

        function findStraightMatchForCell(boardData, row, col) {
            const candidates = getStraightMatchCandidatesForCell(boardData, row, col);
            return candidates.length > 0 ? candidates[0] : null;
        }

        function buildPlayDragPositionKey(row, col) {
            return `${row}-${col}`;
        }

        function isCellDraggableInPlay(boardData, row, col) {
            if (!Array.isArray(boardData)) return false;
            if ((boardData[0]?.length || 0) === 0) return false;

            const rawId = boardData[row]?.[col] ?? EMPTY_CELL_ID;
            const parsed = decodeCellId(rawId);
            if (isEmptyCellId(parsed.baseId)) return false;
            if (!isRemovableBaseId(parsed.baseId)) return false;
            if (isImmobileObstacleBaseId(parsed.baseId)) return false;
            return true;
        }

        function collectAxisConnectedDragCells(
            boardData,
            startRow,
            startCol,
            axis,
            directionStep
        ) {
            if (!Array.isArray(boardData) || boardData.length === 0) return [];
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width === 0) return [];
            if (!isCellDraggableInPlay(boardData, startRow, startCol)) return [];

            const cells = [{ row: startRow, col: startCol }];
            const step = directionStep >= 0 ? 1 : -1;
            if (axis === 'horizontal') {
                let nextCol = startCol + step;
                while (nextCol >= 0 && nextCol < width) {
                    if (!isCellDraggableInPlay(boardData, startRow, nextCol)) break;
                    cells.push({ row: startRow, col: nextCol });
                    nextCol += step;
                }
                cells.sort((left, right) => left.col - right.col);
                return cells;
            }

            if (axis === 'vertical') {
                let nextRow = startRow + step;
                while (nextRow >= 0 && nextRow < height) {
                    if (!isCellDraggableInPlay(boardData, nextRow, startCol)) break;
                    cells.push({ row: nextRow, col: startCol });
                    nextRow += step;
                }
                cells.sort((left, right) => left.row - right.row);
                return cells;
            }

            return cells;
        }

        function applyPlayDragPositions(dragState, positions) {
            if (!dragState) return;
            if (Array.isArray(dragState.cells)) {
                for (const dragCell of dragState.cells) {
                    if (!dragCell.element) continue;
                    dragCell.element.classList.remove('play-dragging');
                    dragCell.element.style.removeProperty('transform');
                }
            }

            const nextPositions = Array.isArray(positions) ? positions : [];
            dragState.positions = nextPositions;
            dragState.positionKeySet = new Set(
                nextPositions.map((position) => buildPlayDragPositionKey(position.row, position.col))
            );
            dragState.cells = nextPositions.map((position) => ({
                row: position.row,
                col: position.col,
                element: document.getElementById(`cell-${position.row}-${position.col}`)
            }));
        }

        function computePlayDragStepLimit(boardData, positions, axis, directionStep, positionKeySet) {
            if (!Array.isArray(boardData) || !Array.isArray(positions)) return 0;
            if (positions.length === 0) return 0;
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width === 0) return 0;

            let limit = Infinity;
            for (const position of positions) {
                let nextRow = position.row;
                let nextCol = position.col;
                let available = 0;
                while (true) {
                    if (axis === 'horizontal') {
                        nextCol += directionStep;
                    } else {
                        nextRow += directionStep;
                    }
                    if (
                        nextRow < 0 ||
                        nextRow >= height ||
                        nextCol < 0 ||
                        nextCol >= width
                    ) {
                        break;
                    }

                    const key = buildPlayDragPositionKey(nextRow, nextCol);
                    if (positionKeySet.has(key)) {
                        available++;
                        continue;
                    }

                    const targetRaw = boardData[nextRow]?.[nextCol] ?? EMPTY_CELL_ID;
                    const targetParsed = decodeCellId(targetRaw);
                    if (!isEmptyCellId(targetParsed.baseId)) break;
                    available++;
                }
                limit = Math.min(limit, available);
            }

            if (!Number.isFinite(limit) || limit < 0) return 0;
            return limit;
        }

        function applyPlayDragPreviewTransform(dragState) {
            if (!dragState || !Array.isArray(dragState.cells)) return;
            const translateX = dragState.axis === 'horizontal'
                ? (dragState.currentOffsetPixels || 0)
                : 0;
            const translateY = dragState.axis === 'vertical'
                ? (dragState.currentOffsetPixels || 0)
                : 0;
            const transformValue = `translate3d(${translateX}px, ${translateY}px, 0)`;

            for (const dragCell of dragState.cells) {
                if (!dragCell.element) continue;
                dragCell.element.classList.add('play-dragging');
                dragCell.element.style.transform = transformValue;
            }
        }

        function clearPlayDragPreviewState(dragState) {
            const targetState = dragState || playDragState;
            if (!targetState) return;
            if (Array.isArray(targetState.cells)) {
                for (const dragCell of targetState.cells) {
                    if (!dragCell.element) continue;
                    dragCell.element.classList.remove('play-dragging');
                    dragCell.element.style.removeProperty('transform');
                }
            }
            const board = document.getElementById('board');
            if (board) board.classList.remove('play-dragging');
        }

        function cancelPlayDrag(resetVisual = true) {
            if (!playDragState) return;
            const currentDragState = playDragState;
            playDragState = null;
            if (resetVisual) clearPlayDragPreviewState(currentDragState);
        }

        function applyPlayDragOffsetToBoards(
            boardData,
            tokenBoard,
            positions,
            deltaRow,
            deltaCol
        ) {
            if (!Array.isArray(boardData) || !Array.isArray(positions)) return;
            const movingValues = positions.map((position) => ({
                fromRow: position.row,
                fromCol: position.col,
                toRow: position.row + deltaRow,
                toCol: position.col + deltaCol,
                cellId: boardData[position.row]?.[position.col] ?? EMPTY_CELL_ID,
                token: Array.isArray(tokenBoard)
                    ? tokenBoard[position.row]?.[position.col] ?? null
                    : null
            }));

            for (const item of movingValues) {
                boardData[item.fromRow][item.fromCol] = EMPTY_CELL_ID;
                if (Array.isArray(tokenBoard)) tokenBoard[item.fromRow][item.fromCol] = null;
            }
            for (const item of movingValues) {
                boardData[item.toRow][item.toCol] = item.cellId;
                if (Array.isArray(tokenBoard)) tokenBoard[item.toRow][item.toCol] = item.token;
            }
        }

        function isPlayBoardCleared(boardData) {
            if (!Array.isArray(boardData)) return true;
            for (const row of boardData) {
                if (!Array.isArray(row)) continue;
                for (const value of row) {
                    const parsed = decodeCellId(value);
                    if (isRemovableBaseId(parsed.baseId)) return false;
                }
            }
            return true;
        }

        function getFourNeighbors(row, col, width, height) {
            const result = [];
            const offsets = [
                [-1, 0],
                [1, 0],
                [0, -1],
                [0, 1]
            ];
            for (const [dr, dc] of offsets) {
                const nextRow = row + dr;
                const nextCol = col + dc;
                if (nextRow < 0 || nextRow >= height || nextCol < 0 || nextCol >= width) continue;
                result.push({ row: nextRow, col: nextCol });
            }
            return result;
        }

        function triggerAdjacentMechanisms(boardData, tokenBoard, removedPositions) {
            if (!Array.isArray(boardData) || !Array.isArray(removedPositions)) return;
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            const targetPositions = new Map();

            for (const position of removedPositions) {
                const neighbors = getFourNeighbors(position.row, position.col, width, height);
                for (const neighbor of neighbors) {
                    targetPositions.set(`${neighbor.row}-${neighbor.col}`, neighbor);
                }
            }

            targetPositions.forEach((position) => {
                const currentId = boardData[position.row]?.[position.col] ?? EMPTY_CELL_ID;
                const parsed = decodeCellId(currentId);

                if (parsed.hasAttachment && ATTACHMENT_IDS.has(parsed.attachmentId)) {
                    boardData[position.row][position.col] = parsed.baseId;
                    return;
                }

                if (parsed.baseId === ICE_LEVEL_1_CELL_ID) {
                    boardData[position.row][position.col] = EMPTY_CELL_ID;
                    if (Array.isArray(tokenBoard)) tokenBoard[position.row][position.col] = null;
                    return;
                }
                if (parsed.baseId === ICE_LEVEL_2_CELL_ID || parsed.baseId === ICE_LEVEL_3_CELL_ID) {
                    boardData[position.row][position.col] = parsed.baseId - 1;
                }
            });
        }

        function removePairFromBoard(boardData, tokenBoard, pair) {
            const removed = [
                { row: pair.row1, col: pair.col1 },
                { row: pair.row2, col: pair.col2 }
            ];
            for (const position of removed) {
                boardData[position.row][position.col] = EMPTY_CELL_ID;
                if (Array.isArray(tokenBoard)) tokenBoard[position.row][position.col] = null;
            }
            return removed;
        }

        function triggerBombEffect(boardData, tokenBoard) {
            const EXTRA_PAIR_COUNT = 3;
            for (let index = 0; index < EXTRA_PAIR_COUNT; index++) {
                const selectedPair = pickRandomRemovablePairForBoard(boardData, false);
                if (!selectedPair) break;
                const removedPositions = removePairFromBoard(boardData, tokenBoard, selectedPair);
                triggerAdjacentMechanisms(boardData, tokenBoard, removedPositions);
            }
        }

        function compressPathPoints(pathPoints) {
            if (!Array.isArray(pathPoints) || pathPoints.length <= 2) return pathPoints || [];
            const compressed = [pathPoints[0]];
            for (let index = 1; index < pathPoints.length - 1; index++) {
                const prev = compressed[compressed.length - 1];
                const current = pathPoints[index];
                const next = pathPoints[index + 1];
                const sameRow = prev.row === current.row && current.row === next.row;
                const sameCol = prev.col === current.col && current.col === next.col;
                if (!sameRow && !sameCol) compressed.push(current);
            }
            compressed.push(pathPoints[pathPoints.length - 1]);
            return compressed;
        }

        function findConnectionPathByLianliankan(boardData, startRow, startCol, targetRow, targetCol) {
            if (!Array.isArray(boardData) || boardData.length === 0) return null;
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width === 0) return null;
            if (startRow === targetRow && startCol === targetCol) return null;

            const extHeight = height + 2;
            const extWidth = width + 2;
            const grid = Array.from({ length: extHeight }, () => Array(extWidth).fill(0));

            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    const value = boardData[row]?.[col];
                    if (Number.isInteger(value) && value > 0) grid[row + 1][col + 1] = value;
                }
            }

            const startExtRow = startRow + 1;
            const startExtCol = startCol + 1;
            const targetExtRow = targetRow + 1;
            const targetExtCol = targetCol + 1;
            if (grid[startExtRow][startExtCol] === 0 || grid[targetExtRow][targetExtCol] === 0) {
                return null;
            }

            const directions = [
                [-1, 0],
                [1, 0],
                [0, -1],
                [0, 1]
            ];
            const visited = Array.from(
                { length: extHeight },
                () => Array.from({ length: extWidth }, () => Array(4).fill(Infinity))
            );

            grid[startExtRow][startExtCol] = 0;
            const queue = [];
            let queueIndex = 0;
            const startPoint = { row: startExtRow, col: startExtCol };

            for (let dir = 0; dir < 4; dir++) {
                const [dr, dc] = directions[dir];
                let nextRow = startExtRow + dr;
                let nextCol = startExtCol + dc;
                while (
                    nextRow >= 0 &&
                    nextRow < extHeight &&
                    nextCol >= 0 &&
                    nextCol < extWidth
                ) {
                    if (nextRow === targetExtRow && nextCol === targetExtCol) {
                        return compressPathPoints([
                            startPoint,
                            { row: nextRow, col: nextCol }
                        ]);
                    }
                    if (grid[nextRow][nextCol] !== 0) break;
                    if (visited[nextRow][nextCol][dir] > 0) {
                        visited[nextRow][nextCol][dir] = 0;
                        queue.push({
                            row: nextRow,
                            col: nextCol,
                            dir,
                            turns: 0,
                            path: [startPoint, { row: nextRow, col: nextCol }]
                        });
                    }
                    nextRow += dr;
                    nextCol += dc;
                }
            }

            while (queueIndex < queue.length) {
                const current = queue[queueIndex];
                queueIndex++;

                for (let nextDir = 0; nextDir < 4; nextDir++) {
                    const nextTurns = current.turns + (nextDir === current.dir ? 0 : 1);
                    if (nextTurns > 2) continue;

                    const [dr, dc] = directions[nextDir];
                    let nextRow = current.row + dr;
                    let nextCol = current.col + dc;

                    while (
                        nextRow >= 0 &&
                        nextRow < extHeight &&
                        nextCol >= 0 &&
                        nextCol < extWidth
                    ) {
                        if (nextRow === targetExtRow && nextCol === targetExtCol) {
                            const targetPath = [...current.path, { row: nextRow, col: nextCol }];
                            return compressPathPoints(targetPath);
                        }
                        if (grid[nextRow][nextCol] !== 0) break;
                        if (visited[nextRow][nextCol][nextDir] > nextTurns) {
                            visited[nextRow][nextCol][nextDir] = nextTurns;
                            queue.push({
                                row: nextRow,
                                col: nextCol,
                                dir: nextDir,
                                turns: nextTurns,
                                path: [...current.path, { row: nextRow, col: nextCol }]
                            });
                        }
                        nextRow += dr;
                        nextCol += dc;
                    }
                }
            }

            return null;
        }

        function getOrCreatePlayLinkOverlay(boardElement) {
            if (!boardElement) return null;
            let overlay = boardElement.querySelector('.play-link-overlay');
            if (overlay) return overlay;
            overlay = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            overlay.setAttribute('class', 'play-link-overlay');
            overlay.setAttribute('aria-hidden', 'true');
            boardElement.appendChild(overlay);
            return overlay;
        }

        function convertExtPathToBoardPixels(extPath, width, height) {
            if (!Array.isArray(extPath) || extPath.length === 0) return [];
            const board = document.getElementById('board');
            const firstCell = document.getElementById('cell-0-0');
            if (!board || !firstCell) return [];

            const boardRect = board.getBoundingClientRect();
            const firstRect = firstCell.getBoundingClientRect();
            const originX = firstRect.left - boardRect.left + (firstRect.width / 2);
            const originY = firstRect.top - boardRect.top + (firstRect.height / 2);
            const { stepX, stepY } = getCellStepDistance();
            const safeWidth = Math.max(1, width);
            const safeHeight = Math.max(1, height);
            const LINK_VERTICAL_OFFSET = -5;

            return extPath.map((point) => {
                const gridCol = Math.max(-1, Math.min(safeWidth, point.col - 1));
                const gridRow = Math.max(-1, Math.min(safeHeight, point.row - 1));
                return {
                    x: originX + (gridCol * stepX),
                    y: originY + (gridRow * stepY) + LINK_VERTICAL_OFFSET
                };
            });
        }

        function renderPlayLinkPath(extPath, width, height) {
            const board = document.getElementById('board');
            if (!board || !Array.isArray(extPath) || extPath.length < 2) return;

            const overlay = getOrCreatePlayLinkOverlay(board);
            if (!overlay) return;
            overlay.innerHTML = '';
            const boardRect = board.getBoundingClientRect();
            overlay.setAttribute('viewBox', `0 0 ${boardRect.width} ${boardRect.height}`);

            const pixelPoints = convertExtPathToBoardPixels(extPath, width, height);
            if (pixelPoints.length < 2) return;

            const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            polyline.setAttribute('class', 'play-link-path');
            polyline.setAttribute('points', pixelPoints.map((pt) => `${pt.x},${pt.y}`).join(' '));
            overlay.appendChild(polyline);
        }

        function clearPlayLinkPath() {
            const board = document.getElementById('board');
            if (!board) return;
            const overlay = board.querySelector('.play-link-overlay');
            if (overlay) overlay.innerHTML = '';
        }

        function startPlayDragByMouseDown(row, col, mouseEvent) {
            if (!playModeState || !playModeState.active) return false;
            if (playModeState.isResolving || playModeState.failed) return false;
            if (!mouseEvent || mouseEvent.button !== 0) return false;
            const boardData = playModeState.boardData;
            if (!Array.isArray(boardData)) return false;

            if (!isCellDraggableInPlay(boardData, row, col)) return false;

            cancelPlayDrag(true);
            suppressPlayModeClickOnce = false;
            clearPlaySelectionVisual();

            const board = document.getElementById('board');
            if (board) board.classList.add('play-dragging');
            const { stepX, stepY } = getCellStepDistance();
            playDragState = {
                active: true,
                startPointerX: mouseEvent.clientX,
                startPointerY: mouseEvent.clientY,
                boardScale: getBoardRenderScale(),
                axis: null,
                axisLocked: false,
                dragDirectionStep: 0,
                currentOffset: 0,
                currentOffsetPixels: 0,
                minOffset: 0,
                maxOffset: 0,
                dragInitiated: false,
                stepX,
                stepY,
                startCell: { row, col },
                positions: [{ row, col }],
                positionKeySet: new Set([buildPlayDragPositionKey(row, col)]),
                cells: [{
                    row,
                    col,
                    element: document.getElementById(`cell-${row}-${col}`)
                }]
            };
            return true;
        }

        function updatePlayDragByMouseMove(mouseEvent) {
            if (!playDragState || !playDragState.active) return;
            if (!playModeState || !playModeState.active) {
                cancelPlayDrag(true);
                return;
            }
            if (!mouseEvent || (mouseEvent.buttons & 1) === 0) return;

            const offsetX = mouseEvent.clientX - playDragState.startPointerX;
            const offsetY = mouseEvent.clientY - playDragState.startPointerY;
            if (!playDragState.axisLocked) {
                const absX = Math.abs(offsetX);
                const absY = Math.abs(offsetY);
                const maxOffset = Math.max(absX, absY);
                if (maxOffset < PLAY_DRAG_AXIS_LOCK_THRESHOLD) return;

                playDragState.axis = absX >= absY ? 'horizontal' : 'vertical';
                playDragState.axisLocked = true;
                playDragState.dragInitiated = true;
            }

            const scale = playDragState.boardScale > 0 ? playDragState.boardScale : 1;
            const axisOffsetScreen = playDragState.axis === 'horizontal' ? offsetX : offsetY;
            const axisOffset = axisOffsetScreen / scale;
            const directionStep = axisOffset >= 0 ? 1 : -1;

            if (!playDragState.dragDirectionStep || playDragState.dragDirectionStep !== directionStep) {
                const axisPositions = collectAxisConnectedDragCells(
                    playModeState.boardData,
                    playDragState.startCell.row,
                    playDragState.startCell.col,
                    playDragState.axis,
                    directionStep
                );
                if (!Array.isArray(axisPositions) || axisPositions.length === 0) return;
                applyPlayDragPositions(playDragState, axisPositions);
                const positiveLimit = computePlayDragStepLimit(
                    playModeState.boardData,
                    playDragState.positions,
                    playDragState.axis,
                    1,
                    playDragState.positionKeySet
                );
                const negativeLimit = computePlayDragStepLimit(
                    playModeState.boardData,
                    playDragState.positions,
                    playDragState.axis,
                    -1,
                    playDragState.positionKeySet
                );
                playDragState.maxOffset = positiveLimit;
                playDragState.minOffset = -negativeLimit;
                playDragState.dragDirectionStep = directionStep;
            }
            const step = playDragState.axis === 'horizontal' ? playDragState.stepX : playDragState.stepY;
            if (!(step > 0)) return;

            const minPixels = playDragState.minOffset * step;
            const maxPixels = playDragState.maxOffset * step;
            const clampedPixels = Math.max(
                minPixels,
                Math.min(maxPixels, axisOffset)
            );
            const snappedOffset = Math.round(clampedPixels / step);
            if (
                clampedPixels === playDragState.currentOffsetPixels &&
                snappedOffset === playDragState.currentOffset
            ) {
                return;
            }

            playDragState.currentOffsetPixels = clampedPixels;
            playDragState.currentOffset = snappedOffset;
            applyPlayDragPreviewTransform(playDragState);
        }

        async function completePlayDrag(mouseEvent) {
            if (!playDragState || !playDragState.active) return;
            const currentDragState = playDragState;
            playDragState = null;
            if (!playModeState || !playModeState.active) {
                clearPlayDragPreviewState(currentDragState);
                return;
            }

            const shouldSuppressClick = currentDragState.dragInitiated;
            if (shouldSuppressClick) suppressPlayModeClickOnce = true;

            const movedSteps = Number.isInteger(currentDragState.currentOffset)
                ? currentDragState.currentOffset
                : 0;
            const hasActualMove = currentDragState.axisLocked && movedSteps !== 0;
            if (!hasActualMove || playModeState.isResolving || playModeState.failed) {
                clearPlayDragPreviewState(currentDragState);
                return;
            }

            const deltaRow = currentDragState.axis === 'vertical' ? movedSteps : 0;
            const deltaCol = currentDragState.axis === 'horizontal' ? movedSteps : 0;
            const previewBoardData = cloneBoardData(playModeState.boardData);
            const previewTokenBoard = cloneBoardData(playModeState.tokenBoard);
            applyPlayDragOffsetToBoards(
                previewBoardData,
                previewTokenBoard,
                currentDragState.positions,
                deltaRow,
                deltaCol
            );

            const movedStartRow = currentDragState.startCell.row + deltaRow;
            const movedStartCol = currentDragState.startCell.col + deltaCol;
            const pairTarget = findStraightMatchForCell(previewBoardData, movedStartRow, movedStartCol);
            if (!pairTarget) {
                clearPlayDragPreviewState(currentDragState);
                setInfoText('试玩模式：拖动结束，未形成配对，卡牌已回位');
                return;
            }

            const movedStartValue = previewBoardData[movedStartRow]?.[movedStartCol];
            const movedStartBaseId = getMatchableBaseId(movedStartValue);
            if (movedStartBaseId === null) {
                clearPlayDragPreviewState(currentDragState);
                return;
            }

            playModeState.boardData = previewBoardData;
            playModeState.tokenBoard = previewTokenBoard;
            clearPlayDragPreviewState(currentDragState);
            syncBoardDisplayWithoutTransition(playModeState.boardData);

            const pair = {
                row1: movedStartRow,
                col1: movedStartCol,
                row2: pairTarget.row,
                col2: pairTarget.col
            };
            await resolvePlayPairRemoval(pair, movedStartBaseId);
        }

        async function resolvePlayPairRemoval(pair, selectedMatchBaseId) {
            if (!playModeState || !playModeState.active || !pair) return false;
            const boardData = playModeState.boardData;
            const info = document.getElementById('info');
            playModeState.isResolving = true;

            const firstCell = document.getElementById(`cell-${pair.row1}-${pair.col1}`);
            const secondCell = document.getElementById(`cell-${pair.row2}-${pair.col2}`);
            if (firstCell) firstCell.classList.add('play-selected');
            if (secondCell) secondCell.classList.add('play-selected');

            try {
                await waitForMs(120);
                if (!playModeState || !playModeState.active) return false;

                if (firstCell) firstCell.classList.add('play-clearing');
                if (secondCell) secondCell.classList.add('play-clearing');

                await waitForMs(120);
                if (!playModeState || !playModeState.active) return false;

                const tokenBoard = playModeState.tokenBoard;
                const removedPositions = removePairFromBoard(boardData, tokenBoard, pair);
                triggerAdjacentMechanisms(boardData, tokenBoard, removedPositions);
                if (selectedMatchBaseId === BOMB_CELL_ID) {
                    triggerBombEffect(boardData, tokenBoard);
                }

                const tokenBeforeShift = cloneBoardData(tokenBoard);
                applyDirectionShiftUntilStable(boardData, 0, tokenBoard);
                syncBoardDisplayWithoutTransition(boardData);
                const movedCells = collectShiftedCells(tokenBeforeShift, tokenBoard);
                await animateBoardShift(movedCells);

                playModeState.clearedPairs = (playModeState.clearedPairs || 0) + 1;
                if (isPlayBoardCleared(boardData)) {
                    updatePlayRetryButton(false);
                    if (info) {
                        info.textContent =
                            `试玩模式：已清空棋盘，共消除 ${playModeState.clearedPairs} 对`;
                    }
                } else {
                    const failed = checkAndHandlePlayFailure(boardData);
                    if (!failed && info) {
                        const remainingPairs = countRemainingPairCountByBoard(boardData);
                        info.textContent =
                            `试玩模式：已消除 ${playModeState.clearedPairs} 对，当前可配对 ${remainingPairs} 对`;
                    }
                }
                return true;
            } finally {
                if (playModeState && playModeState.active) {
                    playModeState.isResolving = false;
                }
            }
        }

        function canConnectByLianliankan(boardData, startRow, startCol, targetRow, targetCol) {
            if (!Array.isArray(boardData) || boardData.length === 0) return false;
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width === 0) return false;
            if (startRow === targetRow && startCol === targetCol) return false;

            const extHeight = height + 2;
            const extWidth = width + 2;
            const grid = Array.from({ length: extHeight }, () => Array(extWidth).fill(0));

            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const value = boardData[i]?.[j];
                    if (Number.isInteger(value) && value > 0) {
                        grid[i + 1][j + 1] = value;
                    }
                }
            }

            const startExtRow = startRow + 1;
            const startExtCol = startCol + 1;
            const targetExtRow = targetRow + 1;
            const targetExtCol = targetCol + 1;

            if (grid[startExtRow][startExtCol] === 0 || grid[targetExtRow][targetExtCol] === 0) {
                return false;
            }

            const directionSteps = [
                [-1, 0],
                [1, 0],
                [0, -1],
                [0, 1]
            ];

            const visited = Array.from(
                { length: extHeight },
                () => Array.from({ length: extWidth }, () => Array(4).fill(Infinity))
            );

            grid[startExtRow][startExtCol] = 0;
            const queue = [];
            let queueIndex = 0;

            for (let dir = 0; dir < 4; dir++) {
                const [dr, dc] = directionSteps[dir];
                let nextRow = startExtRow + dr;
                let nextCol = startExtCol + dc;
                while (
                    nextRow >= 0 &&
                    nextRow < extHeight &&
                    nextCol >= 0 &&
                    nextCol < extWidth
                ) {
                    if (nextRow === targetExtRow && nextCol === targetExtCol) {
                        return true;
                    }
                    if (grid[nextRow][nextCol] !== 0) break;
                    if (visited[nextRow][nextCol][dir] > 0) {
                        visited[nextRow][nextCol][dir] = 0;
                        queue.push({ row: nextRow, col: nextCol, dir, turns: 0 });
                    }
                    nextRow += dr;
                    nextCol += dc;
                }
            }

            while (queueIndex < queue.length) {
                const current = queue[queueIndex];
                queueIndex++;

                for (let nextDir = 0; nextDir < 4; nextDir++) {
                    const nextTurns = current.turns + (nextDir === current.dir ? 0 : 1);
                    if (nextTurns > 2) continue;

                    const [dr, dc] = directionSteps[nextDir];
                    let nextRow = current.row + dr;
                    let nextCol = current.col + dc;

                    while (
                        nextRow >= 0 &&
                        nextRow < extHeight &&
                        nextCol >= 0 &&
                        nextCol < extWidth
                    ) {
                        if (nextRow === targetExtRow && nextCol === targetExtCol) {
                            return true;
                        }
                        if (grid[nextRow][nextCol] !== 0) break;
                        if (visited[nextRow][nextCol][nextDir] > nextTurns) {
                            visited[nextRow][nextCol][nextDir] = nextTurns;
                            queue.push({ row: nextRow, col: nextCol, dir: nextDir, turns: nextTurns });
                        }
                        nextRow += dr;
                        nextCol += dc;
                    }
                }
            }

            return false;
        }

        async function processPlayCellSelection(row, col) {
            if (!playModeState || !playModeState.active || playModeState.isResolving) return;
            if (playModeState.failed) return;
            const boardData = playModeState.boardData;
            const currentValue = boardData?.[row]?.[col];
            if (!isCellClickableInPlay(currentValue)) return;
            const currentMatchBaseId = getMatchableBaseId(currentValue);
            if (currentMatchBaseId === null) return;

            const info = document.getElementById('info');
            const pairTarget = findStraightMatchForCell(boardData, row, col);
            if (!pairTarget) {
                if (info) info.textContent = `试玩模式：${currentMatchBaseId} 当前无法配对`;
                return;
            }

            const pair = {
                row1: row,
                col1: col,
                row2: pairTarget.row,
                col2: pairTarget.col
            };
            await resolvePlayPairRemoval(pair, currentMatchBaseId);
        }

        function exitPlayMode(options = {}) {
            const { restoreBoard = true, silent = false } = options;
            if (!playModeState || !playModeState.active) return;
            cancelPlayDrag(true);
            suppressPlayModeClickOnce = false;

            if (restoreBoard && Array.isArray(playModeState.originalBoard)) {
                syncBoardDisplayByData(playModeState.originalBoard);
                filledCells = cloneBoardData(playModeState.originalBoard);
            }

            const board = document.getElementById('board');
            if (board) board.classList.remove('play-mode');
            clearPlayLinkPath();
            updatePlayRetryButton(false);

            playModeState = null;
            updatePlayModeButton();

            if (!silent) {
                setDefaultInfoText();
            }
        }

        function enterPlayMode() {
            if (playModeState && playModeState.active) return;
            if (!hasFilledCells(filledCells)) {
                alert('请先生成关卡，再进入试玩模式。');
                return;
            }
            if (!ensureBoardPairLegality('试玩')) return;

            resetStepGenerationState();
            const sourceBoard = cloneBoardData(filledCells);
            playModeState = {
                active: true,
                originalBoard: sourceBoard,
                boardData: cloneBoardData(sourceBoard),
                tokenBoard: createTokenBoardFromBoard(sourceBoard),
                selected: null,
                isResolving: false,
                failed: false,
                clearedPairs: 0
            };
            suppressPlayModeClickOnce = false;
            cancelPlayDrag(true);

            const board = document.getElementById('board');
            if (board) board.classList.add('play-mode');

            updatePlayRetryButton(false);
            updatePlayModeButton();
            const info = document.getElementById('info');
            if (info) info.textContent = '试玩模式：点击单牌配对消除，或拖动连片后松手触发配对';
            checkAndHandlePlayFailure(playModeState.boardData);
        }

        function togglePlayMode() {
            if (playModeState && playModeState.active) {
                exitPlayMode({ restoreBoard: true, silent: false });
                return;
            }
            enterPlayMode();
        }

        function stopEditorBrush() {
            editorBrushState.active = false;
            editorBrushState.mode = null;
            editorBrushState.lastCellKey = '';
        }

        function applyEditorBrushAction(row, col) {
            const cellKey = `${row},${col}`;
            if (editorBrushState.lastCellKey === cellKey) return;
            editorBrushState.lastCellKey = cellKey;
            if (editorBrushState.mode === 'clear') {
                clearCellByRightClick(row, col);
                return;
            }
            applyEditorToolOnCell(row, col);
        }

        function handleBoardCellMouseDown(event) {
            if (!event) return;
            const cellElement = event.target.closest('.cell');
            if (!cellElement) return;
            const position = getCellPositionByElement(cellElement);
            if (!position) return;

            if (playModeState && playModeState.active) {
                if (event.button !== 0) return;
                const started = startPlayDragByMouseDown(position.row, position.col, event);
                if (started) event.preventDefault();
                return;
            }

            if (isEditorOperationBlocked()) return;
            if (event.button === 2) {
                event.preventDefault();
                editorBrushState.active = true;
                editorBrushState.mode = 'clear';
                editorBrushState.lastCellKey = '';
                applyEditorBrushAction(position.row, position.col);
                return;
            }

            if (event.button === 0 && canUseEditorBrushForCurrentTool()) {
                event.preventDefault();
                editorBrushState.active = true;
                editorBrushState.mode = 'apply';
                editorBrushState.lastCellKey = '';
                applyEditorBrushAction(position.row, position.col);
            }
        }

        function handleBoardCellMouseMove(event) {
            if (playModeState && playModeState.active && playDragState?.active) {
                updatePlayDragByMouseMove(event);
            }
            if (!editorBrushState.active) return;
            if (isEditorOperationBlocked()) {
                stopEditorBrush();
                return;
            }
            const requiredMask = editorBrushState.mode === 'clear' ? 2 : 1;
            if ((event.buttons & requiredMask) === 0) {
                stopEditorBrush();
                return;
            }
            const cellElement = event.target.closest('.cell');
            if (!cellElement) return;
            const position = getCellPositionByElement(cellElement);
            if (!position) return;
            applyEditorBrushAction(position.row, position.col);
        }

        function handleBoardCellMouseLeave(event) {
            if (playModeState && playModeState.active && playDragState?.active) {
                if (!event || event.buttons === 0) {
                    completePlayDrag(event);
                }
            }
            if (!editorBrushState.active) return;
            if (!event || event.buttons === 0) {
                stopEditorBrush();
            }
        }

        function handleEditorBrushMouseUp(event) {
            stopEditorBrush();
            if (playModeState && playModeState.active && playDragState?.active) {
                completePlayDrag(event);
            }
        }

        function handleDocumentPlayDragMouseMove(event) {
            if (!playModeState || !playModeState.active) return;
            if (!playDragState?.active) return;
            updatePlayDragByMouseMove(event);
        }

        function handleBoardCellClick(event) {
            const cellElement = event.target.closest('.cell');
            if (!cellElement) return;
            const position = getCellPositionByElement(cellElement);
            if (!position) return;
            if (playModeState && playModeState.active) {
                if (suppressPlayModeClickOnce) {
                    suppressPlayModeClickOnce = false;
                    return;
                }
                if (playDragState?.active) return;
                if (playModeState.isResolving) return;
                processPlayCellSelection(position.row, position.col);
                return;
            }
            applyEditorToolOnCell(position.row, position.col);
        }

        function handleBoardCellContextMenu(event) {
            const cellElement = event.target.closest('.cell');
            if (!cellElement) return;
            event.preventDefault();
            if (playModeState && playModeState.active) return;
            if (editorBrushState.active) return;
            const position = getCellPositionByElement(cellElement);
            if (!position) return;
            clearCellByRightClick(position.row, position.col);
        }

        function createLianliankanSearchContext(boardData) {
            if (!Array.isArray(boardData) || boardData.length === 0) return null;
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width === 0) return null;

            const extHeight = height + 2;
            const extWidth = width + 2;
            const cellCount = extHeight * extWidth;
            const stateCount = cellCount * 4;
            const blocked = new Uint8Array(cellCount);

            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    const value = boardData[row][col];
                    if (Number.isInteger(value) && value > 0) {
                        blocked[(row + 1) * extWidth + (col + 1)] = 1;
                    }
                }
            }

            return {
                width,
                height,
                extWidth,
                extHeight,
                blocked,
                visitStamp: new Uint16Array(stateCount),
                visitTurns: new Uint8Array(stateCount),
                stamp: 1,
                queueRow: new Int16Array(stateCount * 4),
                queueCol: new Int16Array(stateCount * 4),
                queueDir: new Uint8Array(stateCount * 4),
                queueTurns: new Uint8Array(stateCount * 4)
            };
        }

        function beginLianliankanSearch(searchContext) {
            if (!searchContext) return;
            searchContext.stamp++;
            if (searchContext.stamp >= 65535) {
                searchContext.visitStamp.fill(0);
                searchContext.stamp = 1;
            }
        }

        function markLianliankanVisited(searchContext, row, col, dir, turns) {
            const stateIndex = (((row * searchContext.extWidth) + col) << 2) + dir;
            const visitedStamp = searchContext.visitStamp[stateIndex];
            if (visitedStamp === searchContext.stamp &&
                searchContext.visitTurns[stateIndex] <= turns) {
                return false;
            }
            searchContext.visitStamp[stateIndex] = searchContext.stamp;
            searchContext.visitTurns[stateIndex] = turns;
            return true;
        }

        function canConnectByLianliankanWithContext(
            searchContext,
            startRow,
            startCol,
            targetRow,
            targetCol
        ) {
            if (!searchContext) return false;
            if (startRow === targetRow && startCol === targetCol) return false;

            const extWidth = searchContext.extWidth;
            const extHeight = searchContext.extHeight;
            const startExtRow = startRow + 1;
            const startExtCol = startCol + 1;
            const targetExtRow = targetRow + 1;
            const targetExtCol = targetCol + 1;
            const startCellIndex = (startExtRow * extWidth) + startExtCol;
            const targetCellIndex = (targetExtRow * extWidth) + targetExtCol;

            if (searchContext.blocked[startCellIndex] === 0 ||
                searchContext.blocked[targetCellIndex] === 0) {
                return false;
            }

            beginLianliankanSearch(searchContext);
            searchContext.blocked[startCellIndex] = 0;

            let queueHead = 0;
            let queueTail = 0;

            for (let dir = 0; dir < 4; dir++) {
                const [dr, dc] = LLK_DIRECTION_STEPS[dir];
                let nextRow = startExtRow + dr;
                let nextCol = startExtCol + dc;
                while (
                    nextRow >= 0 &&
                    nextRow < extHeight &&
                    nextCol >= 0 &&
                    nextCol < extWidth
                ) {
                    if (nextRow === targetExtRow && nextCol === targetExtCol) {
                        searchContext.blocked[startCellIndex] = 1;
                        return true;
                    }
                    const nextIndex = (nextRow * extWidth) + nextCol;
                    if (searchContext.blocked[nextIndex] !== 0) break;
                    if (markLianliankanVisited(searchContext, nextRow, nextCol, dir, 0)) {
                        searchContext.queueRow[queueTail] = nextRow;
                        searchContext.queueCol[queueTail] = nextCol;
                        searchContext.queueDir[queueTail] = dir;
                        searchContext.queueTurns[queueTail] = 0;
                        queueTail++;
                    }
                    nextRow += dr;
                    nextCol += dc;
                }
            }

            while (queueHead < queueTail) {
                const currentRow = searchContext.queueRow[queueHead];
                const currentCol = searchContext.queueCol[queueHead];
                const currentDir = searchContext.queueDir[queueHead];
                const currentTurns = searchContext.queueTurns[queueHead];
                queueHead++;

                for (let nextDir = 0; nextDir < 4; nextDir++) {
                    const nextTurns = currentTurns + (nextDir === currentDir ? 0 : 1);
                    if (nextTurns > 2) continue;

                    const [dr, dc] = LLK_DIRECTION_STEPS[nextDir];
                    let nextRow = currentRow + dr;
                    let nextCol = currentCol + dc;

                    while (
                        nextRow >= 0 &&
                        nextRow < extHeight &&
                        nextCol >= 0 &&
                        nextCol < extWidth
                    ) {
                        if (nextRow === targetExtRow && nextCol === targetExtCol) {
                            searchContext.blocked[startCellIndex] = 1;
                            return true;
                        }
                        const nextIndex = (nextRow * extWidth) + nextCol;
                        if (searchContext.blocked[nextIndex] !== 0) break;
                        if (markLianliankanVisited(searchContext, nextRow, nextCol, nextDir, nextTurns)) {
                            searchContext.queueRow[queueTail] = nextRow;
                            searchContext.queueCol[queueTail] = nextCol;
                            searchContext.queueDir[queueTail] = nextDir;
                            searchContext.queueTurns[queueTail] = nextTurns;
                            queueTail++;
                        }
                        nextRow += dr;
                        nextCol += dc;
                    }
                }
            }

            searchContext.blocked[startCellIndex] = 1;
            return false;
        }

        function getRemovablePairsForBoard(boardData) {
            if (!Array.isArray(boardData) || boardData.length === 0) return [];
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width === 0) return [];

            const pairs = [];
            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    const currentBaseId = getMatchableBaseId(boardData[row]?.[col]);
                    if (currentBaseId === null) continue;

                    for (let rightCol = col + 1; rightCol < width; rightCol++) {
                        const rightValue = boardData[row]?.[rightCol] ?? EMPTY_CELL_ID;
                        const rightParsed = decodeCellId(rightValue);
                        if (isEmptyCellId(rightParsed.baseId)) continue;
                        const rightBaseId = getMatchableBaseId(rightValue);
                        if (rightBaseId === currentBaseId) {
                            pairs.push({
                                row1: row,
                                col1: col,
                                row2: row,
                                col2: rightCol,
                                adjacent: (rightCol - col) === 1
                            });
                        }
                        break;
                    }

                    for (let downRow = row + 1; downRow < height; downRow++) {
                        const downValue = boardData[downRow]?.[col] ?? EMPTY_CELL_ID;
                        const downParsed = decodeCellId(downValue);
                        if (isEmptyCellId(downParsed.baseId)) continue;
                        const downBaseId = getMatchableBaseId(downValue);
                        if (downBaseId === currentBaseId) {
                            pairs.push({
                                row1: row,
                                col1: col,
                                row2: downRow,
                                col2: col,
                                adjacent: (downRow - row) === 1
                            });
                        }
                        break;
                    }
                }
            }
            return pairs;
        }

        function hasAnyRemovablePairForBoard(boardData) {
            if (!Array.isArray(boardData) || boardData.length === 0) return false;
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width === 0) return false;

            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    const currentBaseId = getMatchableBaseId(boardData[row]?.[col]);
                    if (currentBaseId === null) continue;

                    for (let rightCol = col + 1; rightCol < width; rightCol++) {
                        const rightValue = boardData[row]?.[rightCol] ?? EMPTY_CELL_ID;
                        const rightParsed = decodeCellId(rightValue);
                        if (isEmptyCellId(rightParsed.baseId)) continue;
                        if (getMatchableBaseId(rightValue) === currentBaseId) return true;
                        break;
                    }

                    for (let downRow = row + 1; downRow < height; downRow++) {
                        const downValue = boardData[downRow]?.[col] ?? EMPTY_CELL_ID;
                        const downParsed = decodeCellId(downValue);
                        if (isEmptyCellId(downParsed.baseId)) continue;
                        if (getMatchableBaseId(downValue) === currentBaseId) return true;
                        break;
                    }
                }
            }
            return false;
        }

        function hasAnyPlayableActionForBoard(boardData) {
            if (!Array.isArray(boardData) || boardData.length === 0) return false;
            if (hasAnyRemovablePairForBoard(boardData)) return true;

            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width === 0) return false;

            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    if (!isCellDraggableInPlay(boardData, row, col)) continue;
                    for (const axis of ['horizontal', 'vertical']) {
                        for (const directionStep of [-1, 1]) {
                            const positions = collectAxisConnectedDragCells(
                                boardData,
                                row,
                                col,
                                axis,
                                directionStep
                            );
                            if (!Array.isArray(positions) || positions.length === 0) continue;
                            const positionKeySet = new Set(
                                positions.map((position) =>
                                    buildPlayDragPositionKey(position.row, position.col)
                                )
                            );
                            const availableSteps = computePlayDragStepLimit(
                                boardData,
                                positions,
                                axis,
                                directionStep,
                                positionKeySet
                            );
                            if (availableSteps <= 0) continue;

                            for (let step = 1; step <= availableSteps; step++) {
                                const deltaRow = axis === 'vertical' ? step * directionStep : 0;
                                const deltaCol = axis === 'horizontal' ? step * directionStep : 0;
                                const previewBoardData = cloneBoardData(boardData);
                                applyPlayDragOffsetToBoards(
                                    previewBoardData,
                                    null,
                                    positions,
                                    deltaRow,
                                    deltaCol
                                );
                                const movedStartRow = row + deltaRow;
                                const movedStartCol = col + deltaCol;
                                if (
                                    findStraightMatchForCell(
                                        previewBoardData,
                                        movedStartRow,
                                        movedStartCol
                                    )
                                ) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        function countRemainingPairCountByBoard(boardData) {
            if (!Array.isArray(boardData) || boardData.length === 0) return 0;
            return getRemovablePairsForBoard(boardData).length;
        }

        function pickRandomRemovablePairForBoard(boardData, preferAdjacent = false) {
            const pairs = getRemovablePairsForBoard(boardData);
            if (pairs.length === 0) return null;
            if (preferAdjacent) {
                const adjacentPairs = pairs.filter((pair) => pair.adjacent);
                if (adjacentPairs.length > 0) {
                    return adjacentPairs[Math.floor(Math.random() * adjacentPairs.length)];
                }
            }
            return pairs[Math.floor(Math.random() * pairs.length)];
        }

        function pickRandomPair(pairs) {
            if (!pairs || pairs.length === 0) return null;
            const index = Math.floor(Math.random() * pairs.length);
            return pairs[index];
        }

        function buildShuffledIndexArray(length) {
            const size = Number.isFinite(Number(length)) ? Math.max(0, Math.floor(Number(length))) : 0;
            const indexes = [];
            for (let index = 0; index < size; index++) indexes.push(index);
            for (let index = indexes.length - 1; index > 0; index--) {
                const randomIndex = Math.floor(Math.random() * (index + 1));
                const temp = indexes[index];
                indexes[index] = indexes[randomIndex];
                indexes[randomIndex] = temp;
            }
            return indexes;
        }

        function pickRandomPlayableDragActionForBoard(boardData) {
            if (!Array.isArray(boardData) || boardData.length === 0) return null;
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width === 0) return null;

            const axisOptions = ['horizontal', 'vertical'];
            const directionOptions = [-1, 1];
            const cellOrder = buildShuffledIndexArray(width * height);

            for (const cellIndex of cellOrder) {
                const row = Math.floor(cellIndex / width);
                const col = cellIndex % width;
                if (!isCellDraggableInPlay(boardData, row, col)) continue;

                const axisOrder = buildShuffledIndexArray(axisOptions.length);
                for (const axisIndex of axisOrder) {
                    const axis = axisOptions[axisIndex];
                    const directionOrder = buildShuffledIndexArray(directionOptions.length);
                    for (const directionIndex of directionOrder) {
                        const directionStep = directionOptions[directionIndex];
                        const positions = collectAxisConnectedDragCells(
                            boardData,
                            row,
                            col,
                            axis,
                            directionStep
                        );
                        if (!Array.isArray(positions) || positions.length === 0) continue;

                        const positionKeySet = new Set(
                            positions.map((position) =>
                                buildPlayDragPositionKey(position.row, position.col)
                            )
                        );
                        const availableSteps = computePlayDragStepLimit(
                            boardData,
                            positions,
                            axis,
                            directionStep,
                            positionKeySet
                        );
                        if (availableSteps <= 0) continue;

                        const stepOrder = buildShuffledIndexArray(availableSteps).map((step) => step + 1);
                        for (const step of stepOrder) {
                            const deltaRow = axis === 'vertical' ? step * directionStep : 0;
                            const deltaCol = axis === 'horizontal' ? step * directionStep : 0;
                            const previewBoardData = cloneBoardData(boardData);
                            applyPlayDragOffsetToBoards(
                                previewBoardData,
                                null,
                                positions,
                                deltaRow,
                                deltaCol
                            );

                            const movedStartRow = row + deltaRow;
                            const movedStartCol = col + deltaCol;
                            const pairTarget = findStraightMatchForCell(
                                previewBoardData,
                                movedStartRow,
                                movedStartCol
                            );
                            if (!pairTarget) continue;

                            const movedStartBaseId = getMatchableBaseId(
                                previewBoardData[movedStartRow]?.[movedStartCol]
                            );
                            if (movedStartBaseId === null) continue;

                            return {
                                positions,
                                deltaRow,
                                deltaCol,
                                pair: {
                                    row1: movedStartRow,
                                    col1: movedStartCol,
                                    row2: pairTarget.row,
                                    col2: pairTarget.col
                                },
                                selectedBaseId: movedStartBaseId
                            };
                        }
                    }
                }
            }
            return null;
        }

        function applySimulatedPairAction(boardData, pair, selectedBaseId) {
            if (!Array.isArray(boardData) || !pair) return;
            const removedPositions = removePairFromBoard(boardData, null, pair);
            triggerAdjacentMechanisms(boardData, null, removedPositions);
            if (selectedBaseId === BOMB_CELL_ID) {
                triggerBombEffect(boardData, null);
            }
            applyDirectionShiftUntilStable(boardData, 0);
        }

        function applySimulatedDragAction(boardData, dragAction) {
            if (!Array.isArray(boardData) || !dragAction) return;
            applyPlayDragOffsetToBoards(
                boardData,
                null,
                dragAction.positions,
                dragAction.deltaRow,
                dragAction.deltaCol
            );
            applySimulatedPairAction(boardData, dragAction.pair, dragAction.selectedBaseId);
        }

        function getPartitionIndices(length, isFirstPart) {
            const indices = [];
            for (let index = 0; index < length; index++) {
                const inFirstPart = index < (length / 2);
                if ((isFirstPart && inFirstPart) || (!isFirstPart && !inFirstPart)) {
                    indices.push(index);
                }
            }
            return indices;
        }

        function canCellMoveByRules(boardData, row, col) {
            const parsed = decodeCellId(boardData[row]?.[col]);
            if (isEmptyCellId(parsed.baseId)) return true;
            if (isImmobileObstacleBaseId(parsed.baseId)) return false;
            return true;
        }

        function compactSegmentByRules(
            boardData,
            tokenBoard,
            segmentIndices,
            getValue,
            setValue,
            getCoord,
            towardStart
        ) {
            if (!segmentIndices || segmentIndices.length === 0) return false;
            const originalValues = segmentIndices.map((index) => getValue(index));
            const originalTokens = tokenBoard
                ? segmentIndices.map((index) => {
                    const { row, col } = getCoord(index);
                    return tokenBoard[row]?.[col] ?? null;
                })
                : null;

            const fixedIndices = new Set();
            for (let index = 0; index < segmentIndices.length; index++) {
                const value = originalValues[index];
                if (isEmptyCellId(value)) continue;
                const { row, col } = getCoord(segmentIndices[index]);
                if (!canCellMoveByRules(boardData, row, col)) {
                    fixedIndices.add(index);
                }
            }

            const resultValues = [...originalValues];
            const resultTokens = originalTokens ? [...originalTokens] : null;

            let segmentStart = 0;
            while (segmentStart < segmentIndices.length) {
                while (segmentStart < segmentIndices.length && fixedIndices.has(segmentStart)) {
                    segmentStart++;
                }
                if (segmentStart >= segmentIndices.length) break;
                let segmentEnd = segmentStart;
                while (segmentEnd + 1 < segmentIndices.length && !fixedIndices.has(segmentEnd + 1)) {
                    segmentEnd++;
                }

                const movingEntries = [];
                for (let idx = segmentStart; idx <= segmentEnd; idx++) {
                    const value = originalValues[idx];
                    if (isEmptyCellId(value)) continue;
                    movingEntries.push({
                        value,
                        token: resultTokens ? originalTokens[idx] : null
                    });
                    resultValues[idx] = EMPTY_CELL_ID;
                    if (resultTokens) resultTokens[idx] = null;
                }

                const targetSlots = [];
                for (let idx = segmentStart; idx <= segmentEnd; idx++) targetSlots.push(idx);
                const orderedSlots = towardStart ? targetSlots : [...targetSlots].reverse();
                for (let moveIndex = 0; moveIndex < movingEntries.length; moveIndex++) {
                    const slotIndex = orderedSlots[moveIndex];
                    const entry = movingEntries[moveIndex];
                    resultValues[slotIndex] = entry.value;
                    if (resultTokens) resultTokens[slotIndex] = entry.token;
                }

                segmentStart = segmentEnd + 1;
            }

            let changed = false;
            for (let idx = 0; idx < segmentIndices.length; idx++) {
                if (originalValues[idx] !== resultValues[idx]) {
                    changed = true;
                }
                setValue(segmentIndices[idx], resultValues[idx], resultTokens ? resultTokens[idx] : null);
            }
            return changed;
        }

        function applyDirectionShiftOnce(boardData, direction, tokenBoard = null) {
            if (!Array.isArray(boardData) || boardData.length === 0) return false;
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width === 0) return false;

            let changed = false;
            const topRows = getPartitionIndices(height, true);
            const bottomRows = getPartitionIndices(height, false);
            const leftCols = getPartitionIndices(width, true);
            const rightCols = getPartitionIndices(width, false);

            const compactColumn = (colIndex, rowIndices, towardTop) => {
                const segmentChanged = compactSegmentByRules(
                    boardData,
                    tokenBoard,
                    rowIndices,
                    (rowIndex) => boardData[rowIndex]?.[colIndex] ?? null,
                    (rowIndex, value, token) => {
                        boardData[rowIndex][colIndex] = value;
                        if (Array.isArray(tokenBoard)) tokenBoard[rowIndex][colIndex] = token;
                    },
                    (rowIndex) => ({ row: rowIndex, col: colIndex }),
                    towardTop
                );
                if (segmentChanged) changed = true;
            };

            const compactRow = (rowIndex, colIndices, towardLeft) => {
                const segmentChanged = compactSegmentByRules(
                    boardData,
                    tokenBoard,
                    colIndices,
                    (colIndex) => boardData[rowIndex]?.[colIndex] ?? null,
                    (colIndex, value, token) => {
                        boardData[rowIndex][colIndex] = value;
                        if (Array.isArray(tokenBoard)) tokenBoard[rowIndex][colIndex] = token;
                    },
                    (colIndex) => ({ row: rowIndex, col: colIndex }),
                    towardLeft
                );
                if (segmentChanged) changed = true;
            };

            switch (direction) {
                case 1:
                    for (let col = 0; col < width; col++) compactColumn(col, topRows.concat(bottomRows), true);
                    break;
                case 2:
                    for (let col = 0; col < width; col++) compactColumn(col, topRows.concat(bottomRows), false);
                    break;
                case 3:
                    for (let row = 0; row < height; row++) compactRow(row, leftCols.concat(rightCols), true);
                    break;
                case 4:
                    for (let row = 0; row < height; row++) compactRow(row, leftCols.concat(rightCols), false);
                    break;
                case 5:
                    for (let col = 0; col < width; col++) {
                        compactColumn(col, topRows, false);
                        compactColumn(col, bottomRows, true);
                    }
                    break;
                case 6:
                    for (let row = 0; row < height; row++) {
                        compactRow(row, leftCols, false);
                        compactRow(row, rightCols, true);
                    }
                    break;
                case 7:
                    for (let col = 0; col < width; col++) {
                        compactColumn(col, topRows, true);
                        compactColumn(col, bottomRows, false);
                    }
                    break;
                case 8:
                    for (let row = 0; row < height; row++) {
                        compactRow(row, leftCols, true);
                        compactRow(row, rightCols, false);
                    }
                    break;
                default:
                    break;
            }

            return changed;
        }

        function applyDirectionShiftUntilStable(boardData, direction, tokenBoard = null) {
            const maxIterations = (boardData.length || 0) * ((boardData[0]?.length || 0) + 1);
            let iteration = 0;
            while (iteration < maxIterations) {
                const changed = applyDirectionShiftOnce(boardData, direction, tokenBoard);
                if (!changed) break;
                iteration++;
            }
        }

        function countRemovableCellCount(boardData) {
            if (!Array.isArray(boardData)) return 0;
            let count = 0;
            for (const row of boardData) {
                if (!Array.isArray(row)) continue;
                for (const rawId of row) {
                    const parsed = decodeCellId(rawId);
                    if (isRemovableBaseId(parsed.baseId)) count++;
                }
            }
            return count;
        }

        function simulateSingleGame(baseBoardData, direction, initialRemovableCount = null) {
            void direction;
            const boardData = cloneBoardData(baseBoardData);
            const baseCount = Number.isFinite(Number(initialRemovableCount))
                ? Math.max(0, Number(initialRemovableCount))
                : countRemovableCellCount(baseBoardData);
            if (!hasFilledCells(boardData)) {
                return { cleared: false, remainingPercent: 0 };
            }

            const maxSteps = (boardData.length * (boardData[0]?.length || 0)) * 2;
            let stepCount = 0;

            while (stepCount <= maxSteps) {
                const selectedPair = pickRandomRemovablePairForBoard(boardData, true);
                if (selectedPair) {
                    const firstValue = boardData[selectedPair.row1]?.[selectedPair.col1];
                    const selectedBaseId = getMatchableBaseId(firstValue);
                    applySimulatedPairAction(boardData, selectedPair, selectedBaseId);
                    stepCount++;
                    continue;
                }

                const dragAction = pickRandomPlayableDragActionForBoard(boardData);
                if (!dragAction) {
                    const cleared = isPlayBoardCleared(boardData);
                    if (cleared) {
                        return { cleared: true, remainingPercent: 0 };
                    }
                    const remainingCount = countRemovableCellCount(boardData);
                    const remainingPercent = baseCount > 0 ? (remainingCount / baseCount) * 100 : 0;
                    return {
                        cleared: false,
                        remainingPercent: Math.max(0, Math.min(100, remainingPercent))
                    };
                }
                applySimulatedDragAction(boardData, dragAction);
                stepCount++;
            }

            const remainingCount = countRemovableCellCount(boardData);
            const remainingPercent = baseCount > 0 ? (remainingCount / baseCount) * 100 : 0;
            return {
                cleared: false,
                remainingPercent: Math.max(0, Math.min(100, remainingPercent))
            };
        }

        function updateSimulateButtonProgress(progressPercent, labelText) {
            const button = document.getElementById('btnSimulatePlay');
            if (!button) return;
            const numericProgress = Number.isFinite(Number(progressPercent))
                ? Number(progressPercent)
                : 0;
            const safeProgress = Math.max(0, Math.min(100, numericProgress));
            button.style.setProperty('--simulate-progress', safeProgress.toFixed(2));
            if (labelText) button.textContent = labelText;
        }

        function resetSimulateButtonState() {
            const button = document.getElementById('btnSimulatePlay');
            if (!button) return;
            button.disabled = false;
            button.classList.remove('simulating');
            button.style.removeProperty('--simulate-progress');
            button.textContent = '模拟100局';
        }

        function getSimulationWorkerScriptSource() {
            return `
self.onmessage = function(event) {
  const payload = event && event.data ? event.data : {};
  if (payload.type !== 'run') return;
  const games = Number.isInteger(payload.games) ? payload.games : 0;
  const boardData = Array.isArray(payload.boardData) ? payload.boardData : [];
  const direction = Number.isInteger(payload.direction) ? payload.direction : 0;
  runBatch(games, boardData, direction);
};

const EMPTY_CELL_ID = 0;
const PLACEHOLDER_CELL_ID = 499;
const BOMB_CELL_ID = 99;
const ATTACHMENT_MULTIPLIER = 1000;
const ATTACHMENT_IDS = new Set([1, 5]);
const STONE_CELL_ID = 501;
const LEGACY_MAGNET_CELL_ID = 503;
const ICE_LEVEL_1_CELL_ID = 504;
const ICE_LEVEL_2_CELL_ID = 505;
const ICE_LEVEL_3_CELL_ID = 506;
const IMMOBILE_OBSTACLE_IDS = new Set([
  STONE_CELL_ID,
  ICE_LEVEL_1_CELL_ID,
  ICE_LEVEL_2_CELL_ID,
  ICE_LEVEL_3_CELL_ID
]);
const LLK_DIRECTION_STEPS = [
  [-1, 0],
  [1, 0],
  [0, -1],
  [0, 1]
];

function cloneBoardData(boardData) {
  if (!Array.isArray(boardData)) return [];
  return boardData.map((row) => Array.isArray(row) ? row.slice() : []);
}

function hasFilledCells(boardData) {
  if (!Array.isArray(boardData)) return false;
  for (const row of boardData) {
    if (!Array.isArray(row)) continue;
    for (const value of row) {
      if (Number.isInteger(value) && value > 0) return true;
    }
  }
  return false;
}

function isEmptyCellId(cellId) {
  return !Number.isInteger(cellId) || cellId <= 0;
}

function decodeCellId(cellId) {
  if (isEmptyCellId(cellId)) {
    return { baseId: EMPTY_CELL_ID, attachmentId: null, hasAttachment: false };
  }
  if (cellId >= ATTACHMENT_MULTIPLIER) {
    const attachmentId = Math.floor(cellId / ATTACHMENT_MULTIPLIER);
    const rawBaseId = cellId % ATTACHMENT_MULTIPLIER;
    const baseId = rawBaseId === LEGACY_MAGNET_CELL_ID ? STONE_CELL_ID : rawBaseId;
    if (ATTACHMENT_IDS.has(attachmentId) && baseId > 0) {
      return { baseId, attachmentId, hasAttachment: true };
    }
  }
  return {
    baseId: cellId === LEGACY_MAGNET_CELL_ID ? STONE_CELL_ID : cellId,
    attachmentId: null,
    hasAttachment: false
  };
}

function isNormalBaseId(baseId) {
  if (baseId === PLACEHOLDER_CELL_ID) return true;
  return baseId >= 1 && baseId <= 99;
}

function isRemovableBaseId(baseId) {
  return isNormalBaseId(baseId);
}

function isImmobileObstacleBaseId(baseId) {
  return IMMOBILE_OBSTACLE_IDS.has(baseId);
}

function getMatchableBaseId(cellId) {
  const parsed = decodeCellId(cellId);
  if (!isRemovableBaseId(parsed.baseId)) return null;
  if (parsed.hasAttachment) return null;
  return parsed.baseId;
}

function isPlayBoardCleared(boardData) {
  if (!Array.isArray(boardData)) return true;
  for (const row of boardData) {
    if (!Array.isArray(row)) continue;
    for (const value of row) {
      const parsed = decodeCellId(value);
      if (isRemovableBaseId(parsed.baseId)) return false;
    }
  }
  return true;
}

function getFourNeighbors(row, col, width, height) {
  const result = [];
  const offsets = [[-1,0],[1,0],[0,-1],[0,1]];
  for (const [dr, dc] of offsets) {
    const nextRow = row + dr;
    const nextCol = col + dc;
    if (nextRow < 0 || nextRow >= height || nextCol < 0 || nextCol >= width) continue;
    result.push({ row: nextRow, col: nextCol });
  }
  return result;
}

function triggerAdjacentMechanisms(boardData, removedPositions) {
  if (!Array.isArray(boardData) || !Array.isArray(removedPositions)) return;
  const height = boardData.length;
  const width = boardData[0] ? boardData[0].length : 0;
  const targetPositions = new Map();

  for (const position of removedPositions) {
    const neighbors = getFourNeighbors(position.row, position.col, width, height);
    for (const neighbor of neighbors) {
      targetPositions.set(neighbor.row + '-' + neighbor.col, neighbor);
    }
  }

  targetPositions.forEach((position) => {
    const currentId = boardData[position.row][position.col];
    const parsed = decodeCellId(currentId);

    if (parsed.hasAttachment && ATTACHMENT_IDS.has(parsed.attachmentId)) {
      boardData[position.row][position.col] = parsed.baseId;
      return;
    }

    if (parsed.baseId === ICE_LEVEL_1_CELL_ID) {
      boardData[position.row][position.col] = EMPTY_CELL_ID;
      return;
    }
    if (parsed.baseId === ICE_LEVEL_2_CELL_ID || parsed.baseId === ICE_LEVEL_3_CELL_ID) {
      boardData[position.row][position.col] = parsed.baseId - 1;
    }
  });
}

function removePairFromBoard(boardData, pair) {
  const removed = [
    { row: pair.row1, col: pair.col1 },
    { row: pair.row2, col: pair.col2 }
  ];
  for (const position of removed) {
    boardData[position.row][position.col] = EMPTY_CELL_ID;
  }
  return removed;
}

function createLianliankanSearchContext(boardData) {
  if (!Array.isArray(boardData) || boardData.length === 0) return null;
  const height = boardData.length;
  const width = boardData[0] ? boardData[0].length : 0;
  if (width === 0) return null;

  const extHeight = height + 2;
  const extWidth = width + 2;
  const cellCount = extHeight * extWidth;
  const stateCount = cellCount * 4;
  const blocked = new Uint8Array(cellCount);

  for (let row = 0; row < height; row++) {
    for (let col = 0; col < width; col++) {
      const value = boardData[row][col];
      if (Number.isInteger(value) && value > 0) {
        blocked[(row + 1) * extWidth + (col + 1)] = 1;
      }
    }
  }

  return {
    extWidth,
    extHeight,
    blocked,
    visitStamp: new Uint16Array(stateCount),
    visitTurns: new Uint8Array(stateCount),
    stamp: 1,
    queueRow: new Int16Array(stateCount * 4),
    queueCol: new Int16Array(stateCount * 4),
    queueDir: new Uint8Array(stateCount * 4),
    queueTurns: new Uint8Array(stateCount * 4)
  };
}

function beginLianliankanSearch(searchContext) {
  searchContext.stamp++;
  if (searchContext.stamp >= 65535) {
    searchContext.visitStamp.fill(0);
    searchContext.stamp = 1;
  }
}

function markLianliankanVisited(searchContext, row, col, dir, turns) {
  const stateIndex = (((row * searchContext.extWidth) + col) << 2) + dir;
  const visitedStamp = searchContext.visitStamp[stateIndex];
  if (visitedStamp === searchContext.stamp &&
      searchContext.visitTurns[stateIndex] <= turns) {
    return false;
  }
  searchContext.visitStamp[stateIndex] = searchContext.stamp;
  searchContext.visitTurns[stateIndex] = turns;
  return true;
}

function canConnectByLianliankanWithContext(searchContext, startRow, startCol, targetRow, targetCol) {
  if (!searchContext) return false;
  if (startRow === targetRow && startCol === targetCol) return false;

  const extWidth = searchContext.extWidth;
  const extHeight = searchContext.extHeight;
  const startExtRow = startRow + 1;
  const startExtCol = startCol + 1;
  const targetExtRow = targetRow + 1;
  const targetExtCol = targetCol + 1;
  const startCellIndex = (startExtRow * extWidth) + startExtCol;
  const targetCellIndex = (targetExtRow * extWidth) + targetExtCol;

  if (searchContext.blocked[startCellIndex] === 0 || searchContext.blocked[targetCellIndex] === 0) {
    return false;
  }

  beginLianliankanSearch(searchContext);
  searchContext.blocked[startCellIndex] = 0;

  let queueHead = 0;
  let queueTail = 0;

  for (let dir = 0; dir < 4; dir++) {
    const step = LLK_DIRECTION_STEPS[dir];
    let nextRow = startExtRow + step[0];
    let nextCol = startExtCol + step[1];
    while (nextRow >= 0 && nextRow < extHeight && nextCol >= 0 && nextCol < extWidth) {
      if (nextRow === targetExtRow && nextCol === targetExtCol) {
        searchContext.blocked[startCellIndex] = 1;
        return true;
      }
      const nextIndex = (nextRow * extWidth) + nextCol;
      if (searchContext.blocked[nextIndex] !== 0) break;
      if (markLianliankanVisited(searchContext, nextRow, nextCol, dir, 0)) {
        searchContext.queueRow[queueTail] = nextRow;
        searchContext.queueCol[queueTail] = nextCol;
        searchContext.queueDir[queueTail] = dir;
        searchContext.queueTurns[queueTail] = 0;
        queueTail++;
      }
      nextRow += step[0];
      nextCol += step[1];
    }
  }

  while (queueHead < queueTail) {
    const currentRow = searchContext.queueRow[queueHead];
    const currentCol = searchContext.queueCol[queueHead];
    const currentDir = searchContext.queueDir[queueHead];
    const currentTurns = searchContext.queueTurns[queueHead];
    queueHead++;

    for (let nextDir = 0; nextDir < 4; nextDir++) {
      const nextTurns = currentTurns + (nextDir === currentDir ? 0 : 1);
      if (nextTurns > 2) continue;

      const step = LLK_DIRECTION_STEPS[nextDir];
      let nextRow = currentRow + step[0];
      let nextCol = currentCol + step[1];
      while (nextRow >= 0 && nextRow < extHeight && nextCol >= 0 && nextCol < extWidth) {
        if (nextRow === targetExtRow && nextCol === targetExtCol) {
          searchContext.blocked[startCellIndex] = 1;
          return true;
        }
        const nextIndex = (nextRow * extWidth) + nextCol;
        if (searchContext.blocked[nextIndex] !== 0) break;
        if (markLianliankanVisited(searchContext, nextRow, nextCol, nextDir, nextTurns)) {
          searchContext.queueRow[queueTail] = nextRow;
          searchContext.queueCol[queueTail] = nextCol;
          searchContext.queueDir[queueTail] = nextDir;
          searchContext.queueTurns[queueTail] = nextTurns;
          queueTail++;
        }
        nextRow += step[0];
        nextCol += step[1];
      }
    }
  }

  searchContext.blocked[startCellIndex] = 1;
  return false;
}

function getRemovablePairsForBoard(boardData) {
  if (!Array.isArray(boardData) || boardData.length === 0) return [];
  const height = boardData.length;
  const width = boardData[0] ? boardData[0].length : 0;
  if (width === 0) return [];

  const pairs = [];
  for (let row = 0; row < height; row++) {
    for (let col = 0; col < width; col++) {
      const currentBaseId = getMatchableBaseId(boardData[row][col]);
      if (currentBaseId === null) continue;

      for (let rightCol = col + 1; rightCol < width; rightCol++) {
        const rightValue = boardData[row][rightCol];
        const rightParsed = decodeCellId(rightValue);
        if (isEmptyCellId(rightParsed.baseId)) continue;
        const rightBaseId = getMatchableBaseId(rightValue);
        if (rightBaseId === currentBaseId) {
          pairs.push({
            row1: row,
            col1: col,
            row2: row,
            col2: rightCol,
            adjacent: (rightCol - col) === 1
          });
        }
        break;
      }

      for (let downRow = row + 1; downRow < height; downRow++) {
        const downValue = boardData[downRow][col];
        const downParsed = decodeCellId(downValue);
        if (isEmptyCellId(downParsed.baseId)) continue;
        const downBaseId = getMatchableBaseId(downValue);
        if (downBaseId === currentBaseId) {
          pairs.push({
            row1: row,
            col1: col,
            row2: downRow,
            col2: col,
            adjacent: (downRow - row) === 1
          });
        }
        break;
      }
    }
  }
  return pairs;
}

function pickRandomRemovablePairForBoard(boardData, preferAdjacent) {
  const pairs = getRemovablePairsForBoard(boardData);
  if (pairs.length === 0) return null;
  if (preferAdjacent) {
    const adjacentPairs = pairs.filter((pair) => pair.adjacent);
    if (adjacentPairs.length > 0) {
      return adjacentPairs[Math.floor(Math.random() * adjacentPairs.length)];
    }
  }
  return pairs[Math.floor(Math.random() * pairs.length)];
}

function getStraightMatchCandidatesForCell(boardData, row, col) {
  if (!Array.isArray(boardData) || boardData.length === 0) return [];
  const height = boardData.length;
  const width = boardData[0] ? boardData[0].length : 0;
  if (width === 0) return [];
  if (row < 0 || row >= height || col < 0 || col >= width) return [];

  const currentBaseId = getMatchableBaseId(boardData[row][col]);
  if (currentBaseId === null) return [];

  const candidates = [];
  const directions = [
    [-1, 0],
    [1, 0],
    [0, -1],
    [0, 1]
  ];

  for (const step of directions) {
    const dr = step[0];
    const dc = step[1];
    let distance = 1;
    let nextRow = row + dr;
    let nextCol = col + dc;
    while (
      nextRow >= 0 &&
      nextRow < height &&
      nextCol >= 0 &&
      nextCol < width
    ) {
      const nextValue = boardData[nextRow][nextCol];
      const nextParsed = decodeCellId(nextValue);
      if (isEmptyCellId(nextParsed.baseId)) {
        distance++;
        nextRow += dr;
        nextCol += dc;
        continue;
      }
      const nextBaseId = getMatchableBaseId(nextValue);
      if (nextBaseId === currentBaseId) {
        candidates.push({
          row: nextRow,
          col: nextCol,
          distance
        });
      }
      break;
    }
  }

  candidates.sort((left, right) => {
    if (left.distance !== right.distance) return left.distance - right.distance;
    if (left.row !== right.row) return left.row - right.row;
    return left.col - right.col;
  });
  return candidates;
}

function findStraightMatchForCell(boardData, row, col) {
  const candidates = getStraightMatchCandidatesForCell(boardData, row, col);
  return candidates.length > 0 ? candidates[0] : null;
}

function buildPlayDragPositionKey(row, col) {
  return row + '-' + col;
}

function isCellDraggableInPlay(boardData, row, col) {
  if (!Array.isArray(boardData)) return false;
  if ((boardData[0] ? boardData[0].length : 0) === 0) return false;

  const rawId = boardData[row] ? boardData[row][col] : EMPTY_CELL_ID;
  const parsed = decodeCellId(rawId);
  if (isEmptyCellId(parsed.baseId)) return false;
  if (!isRemovableBaseId(parsed.baseId)) return false;
  if (isImmobileObstacleBaseId(parsed.baseId)) return false;
  return true;
}

function collectAxisConnectedDragCells(
  boardData,
  startRow,
  startCol,
  axis,
  directionStep
) {
  if (!Array.isArray(boardData) || boardData.length === 0) return [];
  const height = boardData.length;
  const width = boardData[0] ? boardData[0].length : 0;
  if (width === 0) return [];
  if (!isCellDraggableInPlay(boardData, startRow, startCol)) return [];

  const cells = [{ row: startRow, col: startCol }];
  const step = directionStep >= 0 ? 1 : -1;
  if (axis === 'horizontal') {
    let nextCol = startCol + step;
    while (nextCol >= 0 && nextCol < width) {
      if (!isCellDraggableInPlay(boardData, startRow, nextCol)) break;
      cells.push({ row: startRow, col: nextCol });
      nextCol += step;
    }
    cells.sort((left, right) => left.col - right.col);
    return cells;
  }

  if (axis === 'vertical') {
    let nextRow = startRow + step;
    while (nextRow >= 0 && nextRow < height) {
      if (!isCellDraggableInPlay(boardData, nextRow, startCol)) break;
      cells.push({ row: nextRow, col: startCol });
      nextRow += step;
    }
    cells.sort((left, right) => left.row - right.row);
    return cells;
  }

  return cells;
}

function computePlayDragStepLimit(boardData, positions, axis, directionStep, positionKeySet) {
  if (!Array.isArray(boardData) || !Array.isArray(positions)) return 0;
  if (positions.length === 0) return 0;
  const height = boardData.length;
  const width = boardData[0] ? boardData[0].length : 0;
  if (width === 0) return 0;

  let limit = Infinity;
  for (const position of positions) {
    let nextRow = position.row;
    let nextCol = position.col;
    let available = 0;
    while (true) {
      if (axis === 'horizontal') {
        nextCol += directionStep;
      } else {
        nextRow += directionStep;
      }
      if (
        nextRow < 0 ||
        nextRow >= height ||
        nextCol < 0 ||
        nextCol >= width
      ) {
        break;
      }

      const key = buildPlayDragPositionKey(nextRow, nextCol);
      if (positionKeySet.has(key)) {
        available++;
        continue;
      }

      const targetRaw = boardData[nextRow][nextCol];
      const targetParsed = decodeCellId(targetRaw);
      if (!isEmptyCellId(targetParsed.baseId)) break;
      available++;
    }
    limit = Math.min(limit, available);
  }

  if (!Number.isFinite(limit) || limit < 0) return 0;
  return limit;
}

function applyPlayDragOffsetToBoards(boardData, positions, deltaRow, deltaCol) {
  if (!Array.isArray(boardData) || !Array.isArray(positions)) return;
  const movingValues = positions.map((position) => ({
    fromRow: position.row,
    fromCol: position.col,
    toRow: position.row + deltaRow,
    toCol: position.col + deltaCol,
    cellId: boardData[position.row][position.col]
  }));

  for (const item of movingValues) {
    boardData[item.fromRow][item.fromCol] = EMPTY_CELL_ID;
  }
  for (const item of movingValues) {
    boardData[item.toRow][item.toCol] = item.cellId;
  }
}

function buildShuffledIndexArray(length) {
  const size = Number.isFinite(Number(length)) ? Math.max(0, Math.floor(Number(length))) : 0;
  const indexes = [];
  for (let index = 0; index < size; index++) indexes.push(index);
  for (let index = indexes.length - 1; index > 0; index--) {
    const randomIndex = Math.floor(Math.random() * (index + 1));
    const temp = indexes[index];
    indexes[index] = indexes[randomIndex];
    indexes[randomIndex] = temp;
  }
  return indexes;
}

function pickRandomPlayableDragActionForBoard(boardData) {
  if (!Array.isArray(boardData) || boardData.length === 0) return null;
  const height = boardData.length;
  const width = boardData[0] ? boardData[0].length : 0;
  if (width === 0) return null;

  const axisOptions = ['horizontal', 'vertical'];
  const directionOptions = [-1, 1];
  const cellOrder = buildShuffledIndexArray(width * height);

  for (const cellIndex of cellOrder) {
    const row = Math.floor(cellIndex / width);
    const col = cellIndex % width;
    if (!isCellDraggableInPlay(boardData, row, col)) continue;

    const axisOrder = buildShuffledIndexArray(axisOptions.length);
    for (const axisIndex of axisOrder) {
      const axis = axisOptions[axisIndex];
      const directionOrder = buildShuffledIndexArray(directionOptions.length);
      for (const directionIndex of directionOrder) {
        const directionStep = directionOptions[directionIndex];
        const positions = collectAxisConnectedDragCells(
          boardData,
          row,
          col,
          axis,
          directionStep
        );
        if (!Array.isArray(positions) || positions.length === 0) continue;

        const positionKeySet = new Set(
          positions.map((position) => buildPlayDragPositionKey(position.row, position.col))
        );
        const availableSteps = computePlayDragStepLimit(
          boardData,
          positions,
          axis,
          directionStep,
          positionKeySet
        );
        if (availableSteps <= 0) continue;

        const stepOrder = buildShuffledIndexArray(availableSteps).map((step) => step + 1);
        for (const step of stepOrder) {
          const deltaRow = axis === 'vertical' ? step * directionStep : 0;
          const deltaCol = axis === 'horizontal' ? step * directionStep : 0;
          const previewBoardData = cloneBoardData(boardData);
          applyPlayDragOffsetToBoards(
            previewBoardData,
            positions,
            deltaRow,
            deltaCol
          );

          const movedStartRow = row + deltaRow;
          const movedStartCol = col + deltaCol;
          const pairTarget = findStraightMatchForCell(
            previewBoardData,
            movedStartRow,
            movedStartCol
          );
          if (!pairTarget) continue;

          const movedStartBaseId = getMatchableBaseId(
            previewBoardData[movedStartRow][movedStartCol]
          );
          if (movedStartBaseId === null) continue;

          return {
            positions,
            deltaRow,
            deltaCol,
            pair: {
              row1: movedStartRow,
              col1: movedStartCol,
              row2: pairTarget.row,
              col2: pairTarget.col
            },
            selectedBaseId: movedStartBaseId
          };
        }
      }
    }
  }
  return null;
}

function applySimulatedPairAction(boardData, pair, selectedBaseId) {
  if (!Array.isArray(boardData) || !pair) return;
  const removedPositions = removePairFromBoard(boardData, pair);
  triggerAdjacentMechanisms(boardData, removedPositions);
  if (selectedBaseId === BOMB_CELL_ID) {
    triggerBombEffect(boardData);
  }
  applyDirectionShiftUntilStable(boardData, 0);
}

function applySimulatedDragAction(boardData, dragAction) {
  if (!Array.isArray(boardData) || !dragAction) return;
  applyPlayDragOffsetToBoards(
    boardData,
    dragAction.positions,
    dragAction.deltaRow,
    dragAction.deltaCol
  );
  applySimulatedPairAction(boardData, dragAction.pair, dragAction.selectedBaseId);
}

function triggerBombEffect(boardData) {
  const EXTRA_PAIR_COUNT = 3;
  for (let index = 0; index < EXTRA_PAIR_COUNT; index++) {
    const selectedPair = pickRandomRemovablePairForBoard(boardData, false);
    if (!selectedPair) break;
    const removedPositions = removePairFromBoard(boardData, selectedPair);
    triggerAdjacentMechanisms(boardData, removedPositions);
  }
}

function getPartitionIndices(length, isFirstPart) {
  const indices = [];
  for (let index = 0; index < length; index++) {
    const inFirstPart = index < (length / 2);
    if ((isFirstPart && inFirstPart) || (!isFirstPart && !inFirstPart)) {
      indices.push(index);
    }
  }
  return indices;
}

function canCellMoveByRules(boardData, row, col) {
  const parsed = decodeCellId(boardData[row][col]);
  if (isEmptyCellId(parsed.baseId)) return true;
  if (isImmobileObstacleBaseId(parsed.baseId)) return false;
  return true;
}

function compactSegmentByRules(
  boardData,
  segmentIndices,
  getValue,
  setValue,
  getCoord,
  towardStart
) {
  if (!segmentIndices || segmentIndices.length === 0) return false;
  const originalValues = segmentIndices.map((index) => getValue(index));

  const fixedIndices = new Set();
  for (let index = 0; index < segmentIndices.length; index++) {
    const value = originalValues[index];
    if (isEmptyCellId(value)) continue;
    const coord = getCoord(segmentIndices[index]);
    if (!canCellMoveByRules(boardData, coord.row, coord.col)) {
      fixedIndices.add(index);
    }
  }

  const resultValues = originalValues.slice();

  let segmentStart = 0;
  while (segmentStart < segmentIndices.length) {
    while (segmentStart < segmentIndices.length && fixedIndices.has(segmentStart)) segmentStart++;
    if (segmentStart >= segmentIndices.length) break;
    let segmentEnd = segmentStart;
    while (segmentEnd + 1 < segmentIndices.length && !fixedIndices.has(segmentEnd + 1)) segmentEnd++;

    const movingEntries = [];
    for (let idx = segmentStart; idx <= segmentEnd; idx++) {
      const value = originalValues[idx];
      if (isEmptyCellId(value)) continue;
      movingEntries.push(value);
      resultValues[idx] = EMPTY_CELL_ID;
    }

    const targetSlots = [];
    for (let idx = segmentStart; idx <= segmentEnd; idx++) targetSlots.push(idx);
    const orderedSlots = towardStart ? targetSlots : targetSlots.slice().reverse();
    for (let moveIndex = 0; moveIndex < movingEntries.length; moveIndex++) {
      const slotIndex = orderedSlots[moveIndex];
      resultValues[slotIndex] = movingEntries[moveIndex];
    }

    segmentStart = segmentEnd + 1;
  }

  let changed = false;
  for (let idx = 0; idx < segmentIndices.length; idx++) {
    if (originalValues[idx] !== resultValues[idx]) changed = true;
    setValue(segmentIndices[idx], resultValues[idx]);
  }
  return changed;
}

function applyDirectionShiftOnce(boardData, direction) {
  if (!Array.isArray(boardData) || boardData.length === 0) return false;
  const height = boardData.length;
  const width = boardData[0] ? boardData[0].length : 0;
  if (width === 0) return false;

  let changed = false;
  const topRows = getPartitionIndices(height, true);
  const bottomRows = getPartitionIndices(height, false);
  const leftCols = getPartitionIndices(width, true);
  const rightCols = getPartitionIndices(width, false);

  const compactColumn = (colIndex, rowIndices, towardTop) => {
    const segmentChanged = compactSegmentByRules(
      boardData,
      rowIndices,
      (rowIndex) => boardData[rowIndex][colIndex],
      (rowIndex, value) => { boardData[rowIndex][colIndex] = value; },
      (rowIndex) => ({ row: rowIndex, col: colIndex }),
      towardTop
    );
    if (segmentChanged) changed = true;
  };

  const compactRow = (rowIndex, colIndices, towardLeft) => {
    const segmentChanged = compactSegmentByRules(
      boardData,
      colIndices,
      (colIndex) => boardData[rowIndex][colIndex],
      (colIndex, value) => { boardData[rowIndex][colIndex] = value; },
      (colIndex) => ({ row: rowIndex, col: colIndex }),
      towardLeft
    );
    if (segmentChanged) changed = true;
  };

  switch (direction) {
    case 1:
      for (let col = 0; col < width; col++) compactColumn(col, topRows.concat(bottomRows), true);
      break;
    case 2:
      for (let col = 0; col < width; col++) compactColumn(col, topRows.concat(bottomRows), false);
      break;
    case 3:
      for (let row = 0; row < height; row++) compactRow(row, leftCols.concat(rightCols), true);
      break;
    case 4:
      for (let row = 0; row < height; row++) compactRow(row, leftCols.concat(rightCols), false);
      break;
    case 5:
      for (let col = 0; col < width; col++) {
        compactColumn(col, topRows, false);
        compactColumn(col, bottomRows, true);
      }
      break;
    case 6:
      for (let row = 0; row < height; row++) {
        compactRow(row, leftCols, false);
        compactRow(row, rightCols, true);
      }
      break;
    case 7:
      for (let col = 0; col < width; col++) {
        compactColumn(col, topRows, true);
        compactColumn(col, bottomRows, false);
      }
      break;
    case 8:
      for (let row = 0; row < height; row++) {
        compactRow(row, leftCols, true);
        compactRow(row, rightCols, false);
      }
      break;
    default:
      break;
  }

  return changed;
}

function applyDirectionShiftUntilStable(boardData, direction) {
  const maxIterations = (boardData.length || 0) * ((boardData[0] ? boardData[0].length : 0) + 1);
  let iteration = 0;
  while (iteration < maxIterations) {
    const changed = applyDirectionShiftOnce(boardData, direction);
    if (!changed) break;
    iteration++;
  }
}

function countRemovableCellCount(boardData) {
  if (!Array.isArray(boardData)) return 0;
  let count = 0;
  for (const row of boardData) {
    if (!Array.isArray(row)) continue;
    for (const rawId of row) {
      const parsed = decodeCellId(rawId);
      if (isRemovableBaseId(parsed.baseId)) count++;
    }
  }
  return count;
}

function simulateSingleGame(baseBoardData, direction, initialRemovableCount) {
  void direction;
  const boardData = cloneBoardData(baseBoardData);
  const baseCount = Number.isFinite(Number(initialRemovableCount))
    ? Math.max(0, Number(initialRemovableCount))
    : countRemovableCellCount(baseBoardData);
  if (!hasFilledCells(boardData)) return { cleared: false, remainingPercent: 0 };

  const maxSteps = (boardData.length * ((boardData[0] ? boardData[0].length : 0))) * 2;
  let stepCount = 0;

  while (stepCount <= maxSteps) {
    const selectedPair = pickRandomRemovablePairForBoard(boardData, true);
    if (selectedPair) {
      const firstValue = boardData[selectedPair.row1][selectedPair.col1];
      const selectedBaseId = getMatchableBaseId(firstValue);
      applySimulatedPairAction(boardData, selectedPair, selectedBaseId);
      stepCount++;
      continue;
    }

    const dragAction = pickRandomPlayableDragActionForBoard(boardData);
    if (!dragAction) {
      const cleared = isPlayBoardCleared(boardData);
      if (cleared) return { cleared: true, remainingPercent: 0 };
      const remainingCount = countRemovableCellCount(boardData);
      const remainingPercent = baseCount > 0 ? (remainingCount / baseCount) * 100 : 0;
      return { cleared: false, remainingPercent: Math.max(0, Math.min(100, remainingPercent)) };
    }

    applySimulatedDragAction(boardData, dragAction);
    stepCount++;
  }

  const remainingCount = countRemovableCellCount(boardData);
  const remainingPercent = baseCount > 0 ? (remainingCount / baseCount) * 100 : 0;
  return { cleared: false, remainingPercent: Math.max(0, Math.min(100, remainingPercent)) };
}

function runBatch(games, baseBoardData, direction) {
  let partialCompleted = 0;
  let partialWins = 0;
  let partialFailedGames = 0;
  let partialFailedRemainPercentSum = 0;
  const initialRemovableCount = countRemovableCellCount(baseBoardData);

  for (let gameIndex = 0; gameIndex < games; gameIndex++) {
    const gameResult = simulateSingleGame(baseBoardData, direction, initialRemovableCount);
    if (gameResult && gameResult.cleared) {
      partialWins++;
    } else {
      partialFailedGames++;
      const remainPercent = Number(gameResult?.remainingPercent);
      partialFailedRemainPercentSum += Number.isFinite(remainPercent) ? remainPercent : 0;
    }
    partialCompleted++;

    if (partialCompleted >= 5) {
      postMessage({
        type: 'progress',
        completed: partialCompleted,
        wins: partialWins,
        failedGames: partialFailedGames,
        failedRemainPercentSum: partialFailedRemainPercentSum
      });
      partialCompleted = 0;
      partialWins = 0;
      partialFailedGames = 0;
      partialFailedRemainPercentSum = 0;
    }
  }

  if (partialCompleted > 0) {
    postMessage({
      type: 'progress',
      completed: partialCompleted,
      wins: partialWins,
      failedGames: partialFailedGames,
      failedRemainPercentSum: partialFailedRemainPercentSum
    });
  }
  postMessage({ type: 'done' });
}
`;
        }

        function getSimulationWorkerScriptUrl() {
            if (simulationWorkerScriptUrl) return simulationWorkerScriptUrl;
            const source = getSimulationWorkerScriptSource();
            const blob = new Blob([source], { type: 'text/javascript' });
            simulationWorkerScriptUrl = URL.createObjectURL(blob);
            return simulationWorkerScriptUrl;
        }

        async function runSimulationsInWorkers(
            sourceBoard,
            direction,
            gameCount,
            onProgress,
            shouldStop
        ) {
            if (typeof Worker === 'undefined' || typeof Blob === 'undefined' || typeof URL === 'undefined') {
                return null;
            }

            const hardwareThreads = Math.max(1, parseInt(String(navigator.hardwareConcurrency || 1), 10));
            const workerCount = Math.max(1, Math.min(gameCount, Math.min(8, hardwareThreads - 1)));
            if (workerCount <= 1) return null;

            const baseChunk = Math.floor(gameCount / workerCount);
            const remainder = gameCount % workerCount;
            const chunkSizes = [];
            for (let index = 0; index < workerCount; index++) {
                chunkSizes.push(baseChunk + (index < remainder ? 1 : 0));
            }
            const actualChunks = chunkSizes.filter(size => size > 0);
            if (actualChunks.length <= 1) return null;

            const workerScriptUrl = getSimulationWorkerScriptUrl();
            const workerList = [];

            return new Promise((resolve, reject) => {
                let completedGames = 0;
                let winCount = 0;
                let failedGameCount = 0;
                let failedRemainPercentSum = 0;
                let finishedWorkers = 0;
                let settled = false;

                const cleanupWorkers = () => {
                    for (const worker of workerList) {
                        try {
                            worker.terminate();
                        } catch (_) {}
                    }
                };

                const fail = (error) => {
                    if (settled) return;
                    settled = true;
                    cleanupWorkers();
                    reject(error);
                };

                for (const games of actualChunks) {
                    const worker = new Worker(workerScriptUrl);
                    workerList.push(worker);

                    worker.onmessage = (event) => {
                        if (settled) return;
                        const data = event?.data || {};
                        if (data.type === 'progress') {
                            const done = Number.isFinite(Number(data.completed))
                                ? Number(data.completed)
                                : 0;
                            const wins = Number.isFinite(Number(data.wins))
                                ? Number(data.wins)
                                : 0;
                            const failedGames = Number.isFinite(Number(data.failedGames))
                                ? Number(data.failedGames)
                                : 0;
                            const failedRemainSum = Number.isFinite(Number(data.failedRemainPercentSum))
                                ? Number(data.failedRemainPercentSum)
                                : 0;
                            completedGames += done;
                            winCount += wins;
                            failedGameCount += failedGames;
                            failedRemainPercentSum += failedRemainSum;
                            if (typeof onProgress === 'function') {
                                onProgress(completedGames, gameCount, winCount);
                            }
                            if (
                                typeof shouldStop === 'function' &&
                                shouldStop(completedGames, gameCount, winCount)
                            ) {
                                settled = true;
                                cleanupWorkers();
                                resolve({
                                    winCount,
                                    completedGames,
                                    failedGameCount,
                                    failedRemainPercentSum,
                                    stoppedEarly: true
                                });
                            }
                            return;
                        }
                        if (data.type === 'done') {
                            finishedWorkers++;
                            if (finishedWorkers < actualChunks.length) return;
                            settled = true;
                            cleanupWorkers();
                            resolve({
                                winCount,
                                completedGames,
                                failedGameCount,
                                failedRemainPercentSum,
                                stoppedEarly: false
                            });
                        }
                    };

                    worker.onerror = (error) => {
                        fail(error instanceof Error ? error : new Error('Worker runtime error'));
                    };

                    worker.postMessage({
                        type: 'run',
                        games,
                        boardData: sourceBoard,
                        direction
                    });
                }
            });
        }

        function setSimulationInteractionLock(locked) {
            const body = document.body;
            if (!body) return;
            body.classList.toggle('simulation-locked', Boolean(locked));
        }

        async function simulatePlayGames() {
            const GAME_COUNT = 100;
            if (isSimulatingPlayGames) return;
            if (isBatchGenerating) return;
            if (isBatchCampaignRunning) return;
            const sourceBoard = (playModeState && playModeState.active &&
                Array.isArray(playModeState.originalBoard))
                ? cloneBoardData(playModeState.originalBoard)
                : cloneBoardData(filledCells);
            const direction = 0;

            if (!hasFilledCells(sourceBoard)) {
                alert('请先生成关卡，再进行模拟试玩。');
                return;
            }
            if (!ensureBoardPairLegality('模拟')) return;

            const simulateButton = document.getElementById('btnSimulatePlay');
            isSimulatingPlayGames = true;
            setSimulationInteractionLock(true);
            if (simulateButton) {
                simulateButton.disabled = true;
                simulateButton.classList.add('simulating');
            }
            updateSimulateButtonProgress(0, '模拟中 0%');

            try {
                let winCount = 0;
                let completedGames = 0;
                let usedWorkers = false;

                try {
                    const workerResult = await runSimulationsInWorkers(
                        sourceBoard,
                        direction,
                        GAME_COUNT,
                        (completed, total, currentWins) => {
                            completedGames = completed;
                            winCount = currentWins;
                            const progressPercent = (completed / total) * 100;
                            updateSimulateButtonProgress(
                                progressPercent,
                                `模拟中 ${Math.round(progressPercent)}%`
                            );
                        }
                    );
                    if (workerResult && Number.isFinite(workerResult.winCount)) {
                        usedWorkers = true;
                        winCount = workerResult.winCount;
                        completedGames = workerResult.completedGames || GAME_COUNT;
                    }
                } catch (error) {
                    console.error('Worker simulate failed, fallback to single thread:', error);
                }

                if (!usedWorkers) {
                    const initialRemovableCount = countRemovableCellCount(sourceBoard);
                    for (let gameIndex = 0; gameIndex < GAME_COUNT; gameIndex++) {
                        const gameResult = simulateSingleGame(
                            sourceBoard,
                            direction,
                            initialRemovableCount
                        );
                        if (gameResult?.cleared) {
                            winCount++;
                        }
                        completedGames = gameIndex + 1;
                        const progressPercent = (completedGames / GAME_COUNT) * 100;
                        updateSimulateButtonProgress(
                            progressPercent,
                            `模拟中 ${Math.round(progressPercent)}%`
                        );

                        if (completedGames % 5 === 0) {
                            await waitForMs(0);
                        }
                    }
                }

                const winRate = (winCount / GAME_COUNT) * 100;
                const resultText = `${winCount}/${GAME_COUNT}（${winRate.toFixed(2)}%）`;
                const statsSimulation = document.getElementById('levelStatsSimulation');
                if (statsSimulation) statsSimulation.textContent = resultText;

                const info = document.getElementById('info');
                if (info) {
                    info.textContent = `模拟试玩完成：胜利 ${winCount} 局 / ${GAME_COUNT} 局，胜率 ${winRate.toFixed(2)}%`;
                }
            } finally {
                isSimulatingPlayGames = false;
                setSimulationInteractionLock(false);
                resetSimulateButtonState();
            }
        }

        function normalizeWinRateRangeForSimulation(rawRange, gameCount) {
            if (!Array.isArray(rawRange) || rawRange.length < 2) return null;
            let minRate = Number(rawRange[0]);
            let maxRate = Number(rawRange[1]);
            if (!Number.isFinite(minRate) || !Number.isFinite(maxRate)) return null;
            if (minRate > maxRate) {
                const temp = minRate;
                minRate = maxRate;
                maxRate = temp;
            }
            minRate = Math.max(0, Math.min(100, minRate));
            maxRate = Math.max(0, Math.min(100, maxRate));
            const minWins = Math.ceil((minRate / 100) * gameCount - 1e-9);
            const maxWins = Math.floor((maxRate / 100) * gameCount + 1e-9);
            return { minRate, maxRate, minWins, maxWins };
        }

        function isTargetWinRateRangeUnreachable(
            winCount,
            completedGames,
            gameCount,
            targetWinRange
        ) {
            if (!targetWinRange) return false;
            const remainingGames = Math.max(0, gameCount - completedGames);
            const minPossibleWins = winCount;
            const maxPossibleWins = winCount + remainingGames;
            if (maxPossibleWins < targetWinRange.minWins) return true;
            if (minPossibleWins > targetWinRange.maxWins) return true;
            return false;
        }

        async function simulateBoardWinRate(
            sourceBoard,
            direction,
            gameCount = 100,
            onProgress = null,
            options = {}
        ) {
            const targetWinRange = normalizeWinRateRangeForSimulation(
                options?.winRateRange,
                gameCount
            );
            const enableUnreachableEarlyStop = Boolean(options?.enableUnreachableEarlyStop);
            let winCount = 0;
            let completedGames = 0;
            let failedGameCount = 0;
            let failedRemainPercentSum = 0;
            let usedWorkers = false;
            let stoppedEarly = false;
            let unreachable = false;
            if (targetWinRange && targetWinRange.minWins > targetWinRange.maxWins) {
                return {
                    winCount: 0,
                    completedGames: 0,
                    gameCount,
                    winRate: 0,
                    failedGameCount: 0,
                    failedRemainPercent: 0,
                    stoppedEarly: true,
                    unreachable: true
                };
            }
            try {
                const workerResult = await runSimulationsInWorkers(
                    sourceBoard,
                    direction,
                    gameCount,
                    (completed, total, currentWins) => {
                        completedGames = completed;
                        winCount = currentWins;
                        if (typeof onProgress === 'function') {
                            onProgress(completed, total, currentWins);
                        }
                    },
                    (completed, total, currentWins) => {
                        if (!enableUnreachableEarlyStop || !targetWinRange) return false;
                        return isTargetWinRateRangeUnreachable(
                            currentWins,
                            completed,
                            total,
                            targetWinRange
                        );
                    }
                );
                if (workerResult && Number.isFinite(workerResult.winCount)) {
                    usedWorkers = true;
                    winCount = workerResult.winCount;
                    completedGames = workerResult.completedGames || gameCount;
                    failedGameCount = Number.isFinite(Number(workerResult.failedGameCount))
                        ? Number(workerResult.failedGameCount)
                        : 0;
                    failedRemainPercentSum = Number.isFinite(Number(workerResult.failedRemainPercentSum))
                        ? Number(workerResult.failedRemainPercentSum)
                        : 0;
                    stoppedEarly = Boolean(workerResult.stoppedEarly);
                    unreachable = stoppedEarly &&
                        isTargetWinRateRangeUnreachable(
                            winCount,
                            completedGames,
                            gameCount,
                            targetWinRange
                        );
                }
            } catch (error) {
                console.error('Worker simulate failed, fallback to single thread:', error);
            }

            if (!usedWorkers) {
                const initialRemovableCount = countRemovableCellCount(sourceBoard);
                for (let gameIndex = 0; gameIndex < gameCount; gameIndex++) {
                    const gameResult = simulateSingleGame(
                        sourceBoard,
                        direction,
                        initialRemovableCount
                    );
                    if (gameResult?.cleared) {
                        winCount++;
                    } else {
                        failedGameCount++;
                        const remainPercent = Number(gameResult?.remainingPercent);
                        failedRemainPercentSum += Number.isFinite(remainPercent) ? remainPercent : 0;
                    }
                    completedGames = gameIndex + 1;
                    if (typeof onProgress === 'function') {
                        onProgress(completedGames, gameCount, winCount);
                    }
                    if (enableUnreachableEarlyStop && targetWinRange) {
                        unreachable = isTargetWinRateRangeUnreachable(
                            winCount,
                            completedGames,
                            gameCount,
                            targetWinRange
                        );
                        if (unreachable) {
                            stoppedEarly = true;
                            break;
                        }
                    }
                    if (completedGames % 5 === 0) {
                        await waitForMs(0);
                    }
                }
            }

            const winRate = gameCount > 0 ? (winCount / gameCount) * 100 : 0;
            const failedRemainPercent = failedGameCount > 0
                ? (failedRemainPercentSum / failedGameCount)
                : 0;
            return {
                winCount,
                completedGames,
                gameCount,
                winRate,
                failedGameCount,
                failedRemainPercent,
                stoppedEarly,
                unreachable
            };
        }

        function calculatePool() {
            const { width, height } = getCurrentBoardDimensions();
            const count8 = parseInt(document.getElementById('count8').value) || 0;
            const count6 = parseInt(document.getElementById('count6').value) || 0;

            const totalCells = width * height;
            const cardsFrom8 = count8 * 8;
            const cardsFrom6 = count6 * 6;
            const usedCards = cardsFrom8 + cardsFrom6;

            const errorMsg = document.getElementById('errorMsg');
            const resultSection = document.getElementById('resultSection');

            if (usedCards > totalCells) {
                if (errorMsg) {
                    errorMsg.style.display = 'block';
                    errorMsg.textContent = '错误：超出棋盘容量！';
                }
                if (resultSection) resultSection.style.display = 'none';
                return;
            }

            if (errorMsg) errorMsg.style.display = 'none';
            if (resultSection) resultSection.style.display = 'block';

            const remainingCards = totalCells - usedCards;
            let count4 = Math.floor(remainingCards / 4);
            const remainder = remainingCards % 4;

            let count2 = 0;
            if (remainder >= 2) {
                count2 = 1;
            }

            const totalTypes = count8 + count6 + count4 + count2;
            const totalCards = count8 * 8 + count6 * 6 + count4 * 4 + count2 * 2;

            const result8 = document.getElementById('result8');
            const result6 = document.getElementById('result6');
            const result4 = document.getElementById('result4');
            const result2 = document.getElementById('result2');
            const resultTotalTypes = document.getElementById('resultTotalTypes');
            const resultTotalCards = document.getElementById('resultTotalCards');

            if (result8) result8.textContent = count8;
            if (result6) result6.textContent = count6;
            if (result4) result4.textContent = count4;
            if (result2) result2.textContent = count2;
            if (resultTotalTypes) resultTotalTypes.textContent = totalTypes;
            if (resultTotalCards) resultTotalCards.textContent = totalCards;
        }

        function updateResultSummaryByBoard(boardData) {
            if (!Array.isArray(boardData) || boardData.length === 0) return;

            const countMap = new Map();
            for (const row of boardData) {
                if (!Array.isArray(row)) continue;
                for (const cellId of row) {
                    const baseId = getCardCountBaseId(cellId);
                    if (baseId === null) continue;
                    countMap.set(baseId, (countMap.get(baseId) || 0) + 1);
                }
            }

            const countByCopies = (copies) => {
                let total = 0;
                countMap.forEach((count) => {
                    if (count === copies) total++;
                });
                return total;
            };

            let totalCards = 0;
            countMap.forEach((count) => {
                totalCards += count;
            });

            const result8 = document.getElementById('result8');
            const result6 = document.getElementById('result6');
            const result4 = document.getElementById('result4');
            const result2 = document.getElementById('result2');
            const resultTotalTypes = document.getElementById('resultTotalTypes');
            const resultTotalCards = document.getElementById('resultTotalCards');

            if (result8) result8.textContent = String(countByCopies(8));
            if (result6) result6.textContent = String(countByCopies(6));
            if (result4) result4.textContent = String(countByCopies(4));
            if (result2) result2.textContent = String(countByCopies(2));
            if (resultTotalTypes) resultTotalTypes.textContent = String(countMap.size);
            if (resultTotalCards) resultTotalCards.textContent = String(totalCards);
        }

        function generateBoard() {
            exitPlayMode({ restoreBoard: false, silent: true });
            resetStepGenerationState();
            const { width, height } = getCurrentBoardDimensions();
            const isValidSpec = isSupportedBoardSize(width, height);
            if (!isValidSpec) {
                alert('尺寸请设置为：6×8、8×10、10×12');
                return;
            }

            const btn = document.getElementById('btnExportSingle');
            if (btn) {
                btn.style.background = '';
            }

            calculatePool();
            calculatePoolForGenerate(width, height);

            const board = document.getElementById('board');
            if (!board) return;
            board.innerHTML = '';
            board.style.gridTemplateColumns = `repeat(${width}, 150px)`;
            if (width > 8) board.style.gridTemplateColumns = `repeat(${width}, 120px)`;

            filledCells = [];

            for (let i = 0; i < height; i++) {
                filledCells[i] = [];
                for (let j = 0; j < width; j++) {
                    filledCells[i][j] = EMPTY_CELL_ID;
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${i}-${j}`;
                    board.appendChild(cell);
                }
            }

            setDefaultInfoText();
            resetLevelStats();

            setTimeout(scaleBoard, 100);
        }

        function clearBoard() {
            exitPlayMode({ restoreBoard: false, silent: true });
            resetStepGenerationState();
            if (!filledCells || filledCells.length === 0) return;

            const { width, height } = getCurrentBoardDimensions();

            const btn = document.getElementById('btnExportSingle');
            if (btn) {
                btn.style.background = '';
            }

            for (let i = 0; i < height; i++) {
                if (!filledCells[i]) continue;
                for (let j = 0; j < width; j++) {
                    filledCells[i][j] = EMPTY_CELL_ID;
                    const cell = document.getElementById(`cell-${i}-${j}`);
                    if (cell) {
                        cell.className = 'cell';
                        cell.innerHTML = '';
                    }
                }
            }
            poolCards = [];
            resetLevelStats();
            setDefaultInfoText();
        }

        function getCellColor(num) {
            const colors = [
                'rgba(255, 99, 132, 0.7)',
                'rgba(54, 162, 235, 0.7)',
                'rgba(255, 206, 86, 0.7)',
                'rgba(75, 192, 192, 0.7)',
                'rgba(153, 102, 255, 0.7)',
                'rgba(255, 159, 64, 0.7)',
                'rgba(199, 199, 199, 0.7)',
                'rgba(83, 102, 255, 0.7)',
                'rgba(40, 167, 69, 0.7)',
                'rgba(220, 53, 69, 0.7)',
                'rgba(0, 123, 255, 0.7)',
                'rgba(255, 193, 7, 0.7)',
                'rgba(23, 162, 184, 0.7)',
                'rgba(255, 7, 84, 0.7)',
                'rgba(108, 117, 125, 0.7)',
                'rgba(102, 16, 242, 0.7)',
                'rgba(253, 126, 20, 0.7)',
                'rgba(32, 201, 151, 0.7)',
                'rgba(255, 123, 254, 0.7)',
                'rgba(134, 199, 89, 0.7)'
            ];
            const index = (num - 1) % colors.length;
            return colors[index];
        }

        function resetStepGenerationState() {
            stepGenerationState = null;
            const stepButton = document.getElementById('btnStepGenerate');
            if (stepButton) stepButton.textContent = '分步生成';
        }

        function buildStepGroups(fillOrder, direction) {
            const groups = [];
            let currentGroup = [];
            for (const item of fillOrder) {
                if (item.firstInGroup && currentGroup.length > 0) {
                    groups.push(currentGroup);
                    currentGroup = [];
                }
                currentGroup.push(item);
            }
            if (currentGroup.length > 0) {
                groups.push(currentGroup);
            }

            if (groups.length <= 1) return groups;

            const isRowDirection = isRowBaseDirection(direction);
            const groupMeta = groups.map((group, originalIndex) => {
                let axisIndex = null;
                for (const item of group) {
                    const axisValue = isRowDirection ? item.groupRow : item.groupCol;
                    if (axisValue !== null && axisValue !== undefined) {
                        axisIndex = axisValue;
                        break;
                    }
                }
                return { group, originalIndex, axisIndex };
            });

            const ordered = [groupMeta[0]];
            const used = new Set([groupMeta[0].originalIndex]);

            while (ordered.length < groupMeta.length) {
                const generatedAxis = ordered
                    .map(item => item.axisIndex)
                    .filter(axis => axis !== null && axis !== undefined);

                let best = null;
                for (const candidate of groupMeta) {
                    if (used.has(candidate.originalIndex)) continue;

                    let minGap = Number.POSITIVE_INFINITY;
                    let isAdjacent = false;
                    if (generatedAxis.length > 0 &&
                        candidate.axisIndex !== null &&
                        candidate.axisIndex !== undefined) {
                        for (const axis of generatedAxis) {
                            const gap = Math.abs(candidate.axisIndex - axis);
                            if (gap < minGap) minGap = gap;
                            if (gap === 1) isAdjacent = true;
                        }
                    }

                    if (!best) {
                        best = { candidate, isAdjacent, minGap };
                        continue;
                    }

                    if (isAdjacent && !best.isAdjacent) {
                        best = { candidate, isAdjacent, minGap };
                        continue;
                    }

                    if (isAdjacent === best.isAdjacent) {
                        if (minGap < best.minGap) {
                            best = { candidate, isAdjacent, minGap };
                            continue;
                        }
                        if (minGap === best.minGap &&
                            candidate.originalIndex < best.candidate.originalIndex) {
                            best = { candidate, isAdjacent, minGap };
                        }
                    }
                }

                if (!best) break;
                ordered.push(best.candidate);
                used.add(best.candidate.originalIndex);
            }

            return ordered.map(item => item.group);
        }

        function renderCellNumber(i, j, num) {
            const cell = document.getElementById(`cell-${i}-${j}`);
            if (!cell) return;
            const parsed = decodeCellId(num);
            if (isEmptyCellId(parsed.baseId)) {
                cell.className = 'cell';
                cell.innerHTML = '';
                return;
            }
            if (isObstacleBaseId(parsed.baseId)) {
                cell.className = 'cell filled obstacle-cell';
                cell.innerHTML = '';
                const obstaclePath = getObstacleImagePath(parsed.baseId);
                if (obstaclePath) {
                    const obstacleImage = document.createElement('img');
                    obstacleImage.className = 'card-image-obstacle';
                    if (
                        parsed.baseId === STONE_CELL_ID ||
                        parsed.baseId === WOOD_CELL_ID ||
                        parsed.baseId === ICE_LEVEL_1_CELL_ID ||
                        parsed.baseId === ICE_LEVEL_2_CELL_ID ||
                        parsed.baseId === ICE_LEVEL_3_CELL_ID
                    ) {
                        obstacleImage.classList.add('card-image-obstacle-scale130');
                    }
                    obstacleImage.src = obstaclePath;
                    obstacleImage.alt = String(parsed.baseId);
                    cell.appendChild(obstacleImage);
                }
                return;
            }

            cell.className = 'cell filled playable-card';
            cell.innerHTML = '';
            cell.appendChild(createCardImageStack(parsed.baseId, parsed.attachmentId));
        }

        function createCardImageStack(baseId, attachmentId = null) {
            const BASE_IMAGE_PATH = 'img/base.png';
            const stack = document.createElement('div');
            stack.className = 'card-image-stack';

            const baseImage = document.createElement('img');
            baseImage.className = 'card-image-base';
            baseImage.src = BASE_IMAGE_PATH;
            baseImage.alt = '';
            baseImage.setAttribute('aria-hidden', 'true');

            const guideImage = document.createElement('img');
            guideImage.className = 'card-image-guide';
            guideImage.src = 'img/GuideTips.png';
            guideImage.alt = '';
            guideImage.setAttribute('aria-hidden', 'true');

            const faceImage = document.createElement('img');
            faceImage.className = 'card-image-face';
            if (baseId === BOMB_CELL_ID) {
                faceImage.classList.add('card-image-face-bomb');
                faceImage.src = 'img/zhadan.png';
                faceImage.alt = '99';
            } else {
                const imgNum = getImageForNumber(baseId);
                faceImage.src = `img/${imgNum}.png`;
                faceImage.alt = String(baseId);
            }

            stack.appendChild(baseImage);
            stack.appendChild(guideImage);
            if (baseId !== PLACEHOLDER_CELL_ID) {
                stack.appendChild(faceImage);
            }

            if (ATTACHMENT_IDS.has(attachmentId)) {
                const attachmentPath = getAttachmentImagePath(attachmentId);
                if (attachmentPath) {
                    const attachmentImage = document.createElement('img');
                    attachmentImage.className = 'card-image-attachment';
                    if (attachmentId === ATTACHMENT_FANPAI_ID) {
                        attachmentImage.classList.add('card-image-attachment-fanpai');
                    } else if (attachmentId === ATTACHMENT_ICESHELL_ID) {
                        attachmentImage.classList.add('card-image-attachment-iceshell');
                    }
                    attachmentImage.src = attachmentPath;
                    attachmentImage.alt = String(attachmentId * ATTACHMENT_MULTIPLIER);
                    stack.appendChild(attachmentImage);
                }
            }
            return stack;
        }

        function revealNextStepGroup() {
            if (!stepGenerationState) return;
            const { groups, boardData, direction } = stepGenerationState;
            if (stepGenerationState.currentStepIndex >= groups.length) {
                resetStepGenerationState();
                return;
            }

            const currentGroup = groups[stepGenerationState.currentStepIndex];
            for (const item of currentGroup) {
                const { i, j } = item;
                const num = boardData[i]?.[j] ?? 0;
                if (!filledCells[i]) filledCells[i] = [];
                filledCells[i][j] = num;
                renderCellNumber(i, j, num);
            }

            stepGenerationState.currentStepIndex++;
            updateLevelStats(direction);
            setTimeout(scaleBoard, 100);

            const stepButton = document.getElementById('btnStepGenerate');
            if (!stepButton) return;
            if (stepGenerationState.currentStepIndex >= groups.length) {
                stepButton.textContent = '分步生成';
                stepGenerationState = null;
            } else {
                stepButton.textContent =
                    `下一步 (${stepGenerationState.currentStepIndex}/${groups.length})`;
            }
        }

        function collectPlaceholderFillOrder(fillOrder) {
            const targets = [];
            for (const item of fillOrder) {
                const meta = getFillablePlaceholderMeta(filledCells[item.i]?.[item.j]);
                if (!meta) continue;
                targets.push({
                    ...item,
                    attachmentId: meta.attachmentId
                });
            }
            return targets;
        }

        function validateBeforePlaceholderFill(targetOrder) {
            if (!Array.isArray(targetOrder) || targetOrder.length === 0) {
                alert('当前棋盘没有可填充的占位块（ID:499）。');
                return false;
            }

            if (targetOrder.length % 2 !== 0) {
                alert('占位块数量必须为偶数，当前无法生成成对花色。');
                return false;
            }

            const boardData = getBoardData();
            const countMap = new Map();
            for (const row of boardData) {
                for (const rawId of row) {
                    const parsed = decodeCellId(rawId);
                    if (!isRemovableBaseId(parsed.baseId)) continue;
                    if (parsed.baseId === PLACEHOLDER_CELL_ID) continue;
                    countMap.set(parsed.baseId, (countMap.get(parsed.baseId) || 0) + 1);
                }
            }
            const invalid = [];
            countMap.forEach((count, baseId) => {
                if (count % 2 !== 0) invalid.push(`${baseId}:${count}`);
            });
            if (invalid.length > 0) {
                alert(`填充前校验失败：存在非成对花色（${invalid.join(', ')}）`);
                return false;
            }
            return true;
        }

        function buildPlaceholderFillPlan(direction) {
            const { width, height } = getCurrentBoardDimensions();
            if (!width || !height) return null;

            const fillOrder = getFillOrder(width, height, direction);
            const targetOrder = collectPlaceholderFillOrder(fillOrder);
            if (!validateBeforePlaceholderFill(targetOrder)) return null;

            calculatePool();
            calculatePoolForGenerate(width, height, targetOrder.length);
            if (!Array.isArray(poolCards) || poolCards.length !== targetOrder.length) {
                alert('数字池与占位块数量不匹配，请调整数字配置。');
                return null;
            }

            const boardBefore = cloneBoardData(filledCells);
            const boardAfter = cloneBoardData(filledCells);
            const cardsToPlace = shuffleArray([...poolCards]);

            for (let index = 0; index < targetOrder.length; index++) {
                const target = targetOrder[index];
                const cardNumber = cardsToPlace[index];
                if (!Number.isInteger(cardNumber) || cardNumber <= 0) continue;
                const attachmentId = target.attachmentId;
                boardAfter[target.i][target.j] = ATTACHMENT_IDS.has(attachmentId)
                    ? encodeAttachedCellId(cardNumber, attachmentId)
                    : cardNumber;
            }

            const groups = buildStepGroups(targetOrder, direction);
            return {
                boardBefore,
                boardAfter,
                groups
            };
        }

        function collectRegenerateFillOrder(fillOrder, sourceBoard = filledCells) {
            const targets = [];
            for (const item of fillOrder) {
                const meta = getRegenerateTargetMeta(sourceBoard[item.i]?.[item.j]);
                if (!meta) continue;
                targets.push({
                    ...item,
                    attachmentId: meta.attachmentId
                });
            }
            return targets;
        }

        function validateBeforeRegenerateFill(targetOrder) {
            if (!Array.isArray(targetOrder) || targetOrder.length === 0) {
                alert('当前棋盘没有可重新生成的数字或占位块。');
                return false;
            }

            if (targetOrder.length % 2 !== 0) {
                alert('可生成格子数量必须为偶数，当前无法生成成对花色。');
                return false;
            }
            return true;
        }

        function generateNumbersForTargetOrder(
            targetOrder,
            width,
            height,
            direction,
            sameLie,
            sameNum,
            xianglinSame,
            directionBothCtrl,
            distanceCtrl
        ) {
            const workingBoard = Array.from({ length: height }, () => Array(width).fill(null));
            placedCounts = {};
            currentPool.forEach((item) => {
                placedCounts[item.number] = 0;
            });

            const isRowDirection = isRowBaseDirection(direction);

            const hasPoolNumber = (targetNumber) => {
                const poolItem = currentPool.find(p => p.number === targetNumber);
                return !!poolItem && placedCounts[targetNumber] < poolItem.count;
            };

            const getGroupUsedNumbers = (rowIndex, colIndex) => {
                const usedInGroup = new Set();
                if (isRowDirection) {
                    for (let col = 0; col < width; col++) {
                        const value = workingBoard[rowIndex]?.[col];
                        if (value !== null && value !== undefined) usedInGroup.add(value);
                    }
                } else {
                    for (let row = 0; row < height; row++) {
                        const value = workingBoard[row]?.[colIndex];
                        if (value !== null && value !== undefined) usedInGroup.add(value);
                    }
                }
                return usedInGroup;
            };

            const collectDirectionalSideNumbersForWorkingBoard = (
                rowIndex,
                colIndex,
                localDirection,
                sideType
            ) => {
                const sideNumbers = new Set();
                if (localDirection === 0) return sideNumbers;

                let stepI = 0;
                let stepJ = 0;
                if (localDirection === 1) {
                    stepI = sideType === 'top' ? 1 : -1;
                } else if (localDirection === 2) {
                    stepI = sideType === 'top' ? -1 : 1;
                } else if (localDirection === 3) {
                    stepJ = sideType === 'top' ? 1 : -1;
                } else if (localDirection === 4) {
                    stepJ = sideType === 'top' ? -1 : 1;
                }

                let nextRow = rowIndex + stepI;
                let nextCol = colIndex + stepJ;
                while (nextRow >= 0 && nextRow < height && nextCol >= 0 && nextCol < width) {
                    const value = workingBoard[nextRow]?.[nextCol];
                    if (value !== null && value !== undefined) sideNumbers.add(value);
                    nextRow += stepI;
                    nextCol += stepJ;
                }
                return sideNumbers;
            };

            const chooseCandidateByControl = (rowIndex, colIndex, candidateNumbers) => {
                if (!candidateNumbers || candidateNumbers.length === 0) return null;

                const localDirection = getLocalBaseDirectionByCell(
                    direction,
                    rowIndex,
                    colIndex,
                    width,
                    height
                );
                const upperSet = collectDirectionalSideNumbersForWorkingBoard(
                    rowIndex,
                    colIndex,
                    localDirection,
                    'top'
                );
                const lowerSet = collectDirectionalSideNumbersForWorkingBoard(
                    rowIndex,
                    colIndex,
                    localDirection,
                    'bottom'
                );
                const directionBothSet = new Set();
                upperSet.forEach((value) => {
                    if (lowerSet.has(value)) directionBothSet.add(value);
                });

                let bestScore = -Infinity;
                let bestCandidates = [];
                for (const candidate of candidateNumbers) {
                    const inDirectionBoth = directionBothSet.has(candidate);
                    const directionScore = inDirectionBoth
                        ? directionBothCtrl
                        : (1 - directionBothCtrl);
                    if (directionScore > bestScore) {
                        bestScore = directionScore;
                        bestCandidates = [candidate];
                    } else if (directionScore === bestScore) {
                        bestCandidates.push(candidate);
                    }
                }
                if (bestCandidates.length === 0) return null;
                return bestCandidates[Math.floor(Math.random() * bestCandidates.length)];
            };

            const pickByCandidateNumbers = (rowIndex, colIndex, candidateNumbers, forbiddenNumbers = new Set()) => {
                if (!candidateNumbers || candidateNumbers.length === 0) return null;
                const uniqueCandidates = [];
                const seen = new Set();
                for (const candidate of candidateNumbers) {
                    if (seen.has(candidate)) continue;
                    seen.add(candidate);
                    if (!hasPoolNumber(candidate)) continue;
                    uniqueCandidates.push(candidate);
                }
                if (uniqueCandidates.length === 0) return null;
                const allowedCandidates = uniqueCandidates.filter(
                    candidate => !forbiddenNumbers.has(candidate)
                );
                if (allowedCandidates.length === 0) return null;
                return chooseCandidateByControl(rowIndex, colIndex, allowedCandidates);
            };

            const pickByGroupPreference = (rowIndex, colIndex, preferUsed, forbiddenNumbers = new Set()) => {
                const usedInGroup = getGroupUsedNumbers(rowIndex, colIndex);
                const candidates = [];
                const allowedCandidates = [];
                for (const poolItem of currentPool) {
                    const canUse = placedCounts[poolItem.number] < poolItem.count;
                    if (!canUse) continue;
                    const inGroup = usedInGroup.has(poolItem.number);
                    if ((preferUsed && inGroup) || (!preferUsed && !inGroup)) {
                        candidates.push(poolItem.number);
                        if (!forbiddenNumbers.has(poolItem.number)) {
                            allowedCandidates.push(poolItem.number);
                        }
                    }
                }
                if (candidates.length === 0) return null;
                const source = allowedCandidates.length > 0 ? allowedCandidates : candidates;
                return chooseCandidateByControl(rowIndex, colIndex, source);
            };

            const pickAnyCard = (rowIndex, colIndex, forbiddenNumbers = new Set()) => {
                const candidates = [];
                const allowedCandidates = [];
                for (const poolItem of currentPool) {
                    const canUse = placedCounts[poolItem.number] < poolItem.count;
                    if (!canUse) continue;
                    candidates.push(poolItem.number);
                    if (!forbiddenNumbers.has(poolItem.number)) {
                        allowedCandidates.push(poolItem.number);
                    }
                }
                if (candidates.length === 0) return null;
                const source = allowedCandidates.length > 0 ? allowedCandidates : candidates;
                return chooseCandidateByControl(rowIndex, colIndex, source);
            };

            for (let index = 0; index < targetOrder.length; index++) {
                const { i, j } = targetOrder[index];
                let num = null;

                const adjacentSamePositionNumbers = [];
                if (isRowDirection) {
                    const upNum = i > 0 ? workingBoard[i - 1]?.[j] : null;
                    const downNum = i < height - 1 ? workingBoard[i + 1]?.[j] : null;
                    if (upNum !== null && upNum !== undefined) adjacentSamePositionNumbers.push(upNum);
                    if (downNum !== null && downNum !== undefined) adjacentSamePositionNumbers.push(downNum);
                } else {
                    const leftNum = j > 0 ? workingBoard[i]?.[j - 1] : null;
                    const rightNum = j < width - 1 ? workingBoard[i]?.[j + 1] : null;
                    if (leftNum !== null && leftNum !== undefined) adjacentSamePositionNumbers.push(leftNum);
                    if (rightNum !== null && rightNum !== undefined) adjacentSamePositionNumbers.push(rightNum);
                }

                const adjacentLineSet = new Set();
                if (isRowDirection) {
                    if (i > 0) {
                        for (let col = 0; col < width; col++) {
                            const value = workingBoard[i - 1]?.[col];
                            if (value !== null && value !== undefined) adjacentLineSet.add(value);
                        }
                    }
                    if (i < height - 1) {
                        for (let col = 0; col < width; col++) {
                            const value = workingBoard[i + 1]?.[col];
                            if (value !== null && value !== undefined) adjacentLineSet.add(value);
                        }
                    }
                } else {
                    if (j > 0) {
                        for (let row = 0; row < height; row++) {
                            const value = workingBoard[row]?.[j - 1];
                            if (value !== null && value !== undefined) adjacentLineSet.add(value);
                        }
                    }
                    if (j < width - 1) {
                        for (let row = 0; row < height; row++) {
                            const value = workingBoard[row]?.[j + 1];
                            if (value !== null && value !== undefined) adjacentLineSet.add(value);
                        }
                    }
                }
                const adjacentLineNumbers = Array.from(adjacentLineSet);

                const aroundNeighborSet = new Set();
                for (let di = -1; di <= 1; di++) {
                    for (let dj = -1; dj <= 1; dj++) {
                        if (di === 0 && dj === 0) continue;
                        const ni = i + di;
                        const nj = j + dj;
                        if (ni < 0 || ni >= height || nj < 0 || nj >= width) continue;
                        const value = workingBoard[ni]?.[nj];
                        if (value !== null && value !== undefined) aroundNeighborSet.add(value);
                    }
                }
                const aroundNeighborNumbers = Array.from(aroundNeighborSet);

                const forbiddenNumbers = new Set();
                const tryAdjacentLineSet = Math.random() < sameNum;
                if (!tryAdjacentLineSet) {
                    adjacentLineNumbers.forEach(value => forbiddenNumbers.add(value));
                }

                const trySamePosition = Math.random() < xianglinSame;
                if (trySamePosition) {
                    num = pickByCandidateNumbers(i, j, adjacentSamePositionNumbers, forbiddenNumbers);
                } else {
                    adjacentSamePositionNumbers.forEach(value => forbiddenNumbers.add(value));
                }

                if (num === null && tryAdjacentLineSet) {
                    num = pickByCandidateNumbers(i, j, adjacentLineNumbers, forbiddenNumbers);
                }

                if (num === null) {
                    const preferUsed = Math.random() < sameLie;
                    num = pickByGroupPreference(i, j, preferUsed, forbiddenNumbers);
                    if (num === null) {
                        num = pickByGroupPreference(i, j, !preferUsed, forbiddenNumbers);
                    }
                }

                if (num === null) {
                    num = pickAnyCard(i, j, forbiddenNumbers);
                }

                if (num === null) {
                    num = getNextCard();
                }

                if (num !== null) {
                    if (aroundNeighborSet.has(num) && Math.random() >= distanceCtrl) {
                        const replaceForbidden = new Set(forbiddenNumbers);
                        aroundNeighborNumbers.forEach(value => replaceForbidden.add(value));
                        const preferUsedForReplace = Math.random() < sameLie;
                        let replacement = pickByGroupPreference(
                            i,
                            j,
                            preferUsedForReplace,
                            replaceForbidden
                        );
                        if (replacement === null) {
                            replacement = pickByGroupPreference(
                                i,
                                j,
                                !preferUsedForReplace,
                                replaceForbidden
                            );
                        }
                        if (replacement === null && tryAdjacentLineSet) {
                            replacement = pickByCandidateNumbers(
                                i,
                                j,
                                adjacentLineNumbers,
                                replaceForbidden
                            );
                        }
                        if (replacement === null) {
                            replacement = pickAnyCard(i, j, replaceForbidden);
                        }
                        if (replacement !== null) num = replacement;
                    }

                    const reservedCard = getSpecificCard(num);
                    if (reservedCard === null) {
                        num = getNextCard();
                    }
                }

                if (num !== null) {
                    placedCounts[num] = (placedCounts[num] || 0) + 1;
                    workingBoard[i][j] = num;
                }
            }

            return workingBoard;
        }

        function buildRegenerateFillPlan(direction) {
            const { width, height } = getCurrentBoardDimensions();
            if (!width || !height) return null;

            const fillOrder = getFillOrder(width, height, direction);
            const targetOrder = collectRegenerateFillOrder(fillOrder);
            if (!validateBeforeRegenerateFill(targetOrder)) return null;

            calculatePool();
            calculatePoolForGenerate(width, height, targetOrder.length);
            if (!Array.isArray(poolCards) || poolCards.length !== targetOrder.length) {
                alert('数字池与可生成格子数量不匹配，请调整数字配置。');
                return null;
            }
            const sameLie = getProbabilityValue('sameLie', 0.1);
            const sameNum = getProbabilityValue('sameNum', 0.1);
            const xianglinSame = getProbabilityValue('xianglinSame', 0.1);
            const distanceCtrl = getProbabilityValue('distanceCtrl', 0.1);

            const boardBefore = cloneBoardData(filledCells);
            const boardAfter = cloneBoardData(filledCells);
            const generatedBoard = generateNumbersForTargetOrder(
                targetOrder,
                width,
                height,
                direction,
                sameLie,
                sameNum,
                xianglinSame,
                directionBothCtrl,
                distanceCtrl
            );

            for (let index = 0; index < targetOrder.length; index++) {
                const target = targetOrder[index];
                const cardNumber = generatedBoard[target.i]?.[target.j];
                if (!Number.isInteger(cardNumber) || cardNumber <= 0) continue;
                const attachmentId = target.attachmentId;
                boardAfter[target.i][target.j] = ATTACHMENT_IDS.has(attachmentId)
                    ? encodeAttachedCellId(cardNumber, attachmentId)
                    : cardNumber;
            }

            const groups = buildStepGroups(targetOrder, direction);
            return {
                boardBefore,
                boardAfter,
                groups
            };
        }

        function buildRegenerateFillPlanForBoard(sourceBoard, options = {}) {
            if (!Array.isArray(sourceBoard) || sourceBoard.length === 0) {
                return { success: false, message: '棋盘数据为空。' };
            }
            const height = sourceBoard.length;
            const width = sourceBoard[0]?.length || 0;
            if (width <= 0) {
                return { success: false, message: '棋盘宽度无效。' };
            }
            const isRectBoard = sourceBoard.every((row) => Array.isArray(row) && row.length === width);
            if (!isRectBoard) {
                return { success: false, message: '棋盘数据必须是规则二维数组。' };
            }

            const safeDirection = 0;

            const fillOrder = getFillOrder(width, height, safeDirection);
            const targetOrder = collectRegenerateFillOrder(fillOrder, sourceBoard);
            if (!Array.isArray(targetOrder) || targetOrder.length === 0) {
                return { success: false, message: '当前棋盘没有可重新生成的数字或占位块。' };
            }
            if (targetOrder.length % 2 !== 0) {
                return { success: false, message: '可生成格子数量必须为偶数。' };
            }

            const sameLie = Math.max(
                0,
                Math.min(
                    1,
                    Number.isFinite(Number(options.sameLie)) ? Number(options.sameLie) : 0.1
                )
            );
            const sameNum = Math.max(
                0,
                Math.min(
                    1,
                    Number.isFinite(Number(options.sameNum)) ? Number(options.sameNum) : 0.1
                )
            );
            const xianglinSame = Math.max(
                0,
                Math.min(
                    1,
                    Number.isFinite(Number(options.xianglinSame))
                        ? Number(options.xianglinSame)
                        : 0.1
                )
            );
            const directionBothCtrl = Math.max(
                0,
                Math.min(
                    1,
                    Number.isFinite(Number(options.directionBothCtrl))
                        ? Number(options.directionBothCtrl)
                        : 0.5
                )
            );
            const distanceCtrl = Math.max(
                0,
                Math.min(
                    1,
                    Number.isFinite(Number(options.distanceCtrl))
                        ? Number(options.distanceCtrl)
                        : 0.1
                )
            );
            const count8Override = Number.isFinite(Number(options.count8))
                ? Math.max(0, Math.floor(Number(options.count8)))
                : null;
            const count6Override = Number.isFinite(Number(options.count6))
                ? Math.max(0, Math.floor(Number(options.count6)))
                : null;

            calculatePoolForGenerate(
                width,
                height,
                targetOrder.length,
                count8Override,
                count6Override
            );
            if (!Array.isArray(poolCards) || poolCards.length !== targetOrder.length) {
                return { success: false, message: '数字池与可生成格子数量不匹配。' };
            }

            const boardAfter = cloneBoardData(sourceBoard);
            const generatedBoard = generateNumbersForTargetOrder(
                targetOrder,
                width,
                height,
                safeDirection,
                sameLie,
                sameNum,
                xianglinSame,
                directionBothCtrl,
                distanceCtrl
            );

            for (let index = 0; index < targetOrder.length; index++) {
                const target = targetOrder[index];
                const cardNumber = generatedBoard[target.i]?.[target.j];
                if (!Number.isInteger(cardNumber) || cardNumber <= 0) continue;
                const attachmentId = target.attachmentId;
                boardAfter[target.i][target.j] = ATTACHMENT_IDS.has(attachmentId)
                    ? encodeAttachedCellId(cardNumber, attachmentId)
                    : cardNumber;
            }

            return {
                success: true,
                boardData: boardAfter,
                generatedCellCount: targetOrder.length
            };
        }

        function startStepGeneration() {
            exitPlayMode({ restoreBoard: false, silent: true });
            shuffleImages();
            const { width, height } = getCurrentBoardDimensions();
            if (!width || !height) return;

            const direction = getCurrentDirectionValue();
            const fillPlan = buildPlaceholderFillPlan(direction);
            if (!fillPlan) return;

            filledCells = cloneBoardData(fillPlan.boardBefore);
            syncBoardDisplayByData(filledCells);

            stepGenerationState = {
                boardData: fillPlan.boardAfter,
                groups: fillPlan.groups,
                currentStepIndex: 0,
                direction
            };

            if (fillPlan.groups.length === 0) {
                resetStepGenerationState();
                return;
            }
            revealNextStepGroup();
        }

        function stepGenerateOrNext() {
            if (!stepGenerationState) {
                startStepGeneration();
                return;
            }
            revealNextStepGroup();
        }

        function fillBoard() {
            exitPlayMode({ restoreBoard: false, silent: true });
            resetStepGenerationState();
            shuffleImages();
            const { width, height } = getCurrentBoardDimensions();
            if (!width || !height) return;

            const direction = getCurrentDirectionValue();

            const btn = document.getElementById('btnExportSingle');
            if (btn) {
                btn.style.background = '';
            }

            const fillPlan = buildRegenerateFillPlan(direction);
            if (!fillPlan) return;
            filledCells = cloneBoardData(fillPlan.boardAfter);
            syncBoardDisplayByData(filledCells);
            updateResultSummaryByBoard(filledCells);
            updateLevelStats(direction);
            setTimeout(scaleBoard, 100);
        }

        function resetLevelStats() {
            const statsSimulation = document.getElementById('levelStatsSimulation');
            if (statsSimulation) statsSimulation.textContent = '-';
        }

        function updateLevelStats(direction) {
            void direction;
            const statsSimulation = document.getElementById('levelStatsSimulation');
            if (statsSimulation) statsSimulation.textContent = '-';
        }

        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        function getFillOrder(width, height, direction) {
            const order = [];
            const used = new Set();

            const addCell = (i, j, firstInGroup, groupCol, groupRow) => {
                const key = `${i},${j}`;
                if (!used.has(key)) {
                    order.push({i, j, prevI: null, prevJ: null, firstInGroup, groupCol, groupRow});
                    used.add(key);
                }
            };

            const addAdjacent = (i, j, isRow, firstInGroup, groupCol, groupRow) => {
                const neighbors = isRow
                    ? [[i, j-1], [i, j+1]]
                    : [[i-1, j], [i+1, j]];
                for (const [ni, nj] of neighbors) {
                    if (ni >= 0 && ni < height && nj >= 0 && nj < width) {
                        const key = `${ni},${nj}`;
                        if (!used.has(key)) {
                            order.push({i: ni, j: nj, prevI: i, prevJ: j, firstInGroup: false, groupCol, groupRow});
                            used.add(key);
                        }
                    }
                }
            };

            switch (direction) {
                case 0: {
                    const cols = shuffleArray(Array.from({length: width}, (_, i) => i));
                    for (let colIdx = 0; colIdx < cols.length; colIdx++) {
                        const col = cols[colIdx];
                        for (let i = 0; i < height; i++) {
                            const firstInGroup = (i === 0);
                            addCell(i, col, firstInGroup, col, null);
                            if (i < height - 1) {
                                addAdjacent(i, col, false, false, col, null);
                            }
                        }
                    }
                    break;
                }
                case 1: {
                    for (let j = 0; j < width; j++) {
                        for (let i = height - 1; i >= 0; i--) {
                            const firstInGroup = (i === height - 1);
                            addCell(i, j, firstInGroup, j, null);
                            if (i > 0) {
                                addAdjacent(i, j, false, false, j, null);
                            }
                        }
                    }
                    break;
                }
                case 2: {
                    for (let j = 0; j < width; j++) {
                        for (let i = 0; i < height; i++) {
                            const firstInGroup = (i === 0);
                            addCell(i, j, firstInGroup, j, null);
                            if (i < height - 1) {
                                addAdjacent(i, j, false, false, j, null);
                            }
                        }
                    }
                    break;
                }
                case 3: {
                    const rows = shuffleArray(Array.from({length: height}, (_, i) => i));
                    for (let rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                        const row = rows[rowIdx];
                        for (let j = width - 1; j >= 0; j--) {
                            const firstInGroup = (j === width - 1);
                            addCell(row, j, firstInGroup, null, row);
                            if (j > 0) {
                                addAdjacent(row, j, true, false, null, row);
                            }
                        }
                    }
                    break;
                }
                case 4: {
                    const rows = shuffleArray(Array.from({length: height}, (_, i) => i));
                    for (let rowIdx = 0; rowIdx < rows.length; rowIdx++) {
                        const row = rows[rowIdx];
                        for (let j = 0; j < width; j++) {
                            const firstInGroup = (j === 0);
                            addCell(row, j, firstInGroup, null, row);
                            if (j < width - 1) {
                                addAdjacent(row, j, true, false, null, row);
                            }
                        }
                    }
                    break;
                }
                case 5: {
                    const colsIn = [...Array(width).keys()].sort((a, b) => Math.abs(a - width / 2) - Math.abs(b - width / 2)).reverse();
                    for (let colIdx = 0; colIdx < colsIn.length; colIdx++) {
                        const col = colsIn[colIdx];
                        for (let i = 0; i < height; i++) {
                            const firstInGroup = (i === 0);
                            addCell(i, col, firstInGroup, col, null);
                            if (i < height - 1) {
                                addAdjacent(i, col, false, false, col, null);
                            }
                        }
                    }
                    break;
                }
                case 6: {
                    const rowsIn = [...Array(height).keys()].sort((a, b) => Math.abs(a - height / 2) - Math.abs(b - height / 2)).reverse();
                    for (let rowIdx = 0; rowIdx < rowsIn.length; rowIdx++) {
                        const row = rowsIn[rowIdx];
                        for (let j = 0; j < width; j++) {
                            const firstInGroup = (j === 0);
                            addCell(row, j, firstInGroup, null, row);
                            if (j < width - 1) {
                                addAdjacent(row, j, true, false, null, row);
                            }
                        }
                    }
                    break;
                }
                case 7: {
                    const colsOut = [...Array(width).keys()].sort((a, b) => Math.abs(a - width / 2) - Math.abs(b - width / 2));
                    for (let colIdx = 0; colIdx < colsOut.length; colIdx++) {
                        const col = colsOut[colIdx];
                        for (let i = 0; i < height; i++) {
                            const firstInGroup = (i === 0);
                            addCell(i, col, firstInGroup, col, null);
                            if (i < height - 1) {
                                addAdjacent(i, col, false, false, col, null);
                            }
                        }
                    }
                    break;
                }
                case 8: {
                    const rowsOut = [...Array(height).keys()].sort((a, b) => Math.abs(a - height / 2) - Math.abs(b - height / 2));
                    for (let rowIdx = 0; rowIdx < rowsOut.length; rowIdx++) {
                        const row = rowsOut[rowIdx];
                        for (let j = 0; j < width; j++) {
                            const firstInGroup = (j === 0);
                            addCell(row, j, firstInGroup, null, row);
                            if (j < width - 1) {
                                addAdjacent(row, j, true, false, null, row);
                            }
                        }
                    }
                    break;
                }
            }
            return order;
        }

        function getPoolCards() {
            if (poolCards.length > 0) return poolCards;
            if (!currentPool || currentPool.length === 0) return [];
            poolCards = [];
            currentPool.forEach(poolItem => {
                for (let i = 0; i < poolItem.count; i++) poolCards.push(poolItem.number);
            });
            poolCards = shuffleArray(poolCards);
            return poolCards;
        }

        function getNextCard() {
            const cards = getPoolCards();
            return cards && cards.length > 0 ? cards.pop() : null;
        }

        function getSpecificCard(targetNumber) {
            const cards = getPoolCards();
            if (!cards || cards.length === 0) return null;
            const cardIndex = cards.indexOf(targetNumber);
            if (cardIndex === -1) return null;
            cards.splice(cardIndex, 1);
            return targetNumber;
        }

        function exportConfigToClipboard() {
            const { width, height } = getCurrentBoardDimensions();
            const count8 = parseInt(document.getElementById('count8')?.value, 10) || 0;
            const count6 = parseInt(document.getElementById('count6')?.value, 10) || 0;
            const sameLie = getProbabilityValue('sameLie', 0.1);
            const sameNum = getProbabilityValue('sameNum', 0.1);
            const xianglinSame = getProbabilityValue('xianglinSame', 0.1);
            const distanceCtrl = getProbabilityValue('distanceCtrl', 0.1);

            const toCompactNumber = (value) => String(Number(value.toFixed(2)));
            const values = [
                width,
                height,
                count8,
                count6,
                toCompactNumber(sameLie),
                toCompactNumber(sameNum),
                toCompactNumber(xianglinSame),
                toCompactNumber(distanceCtrl)
            ];

            const tsvText = values.join('\t');
            navigator.clipboard.writeText(tsvText).then(() => {
                const info = document.getElementById('info');
                if (info) {
                    info.textContent = '配置数值已复制到剪贴板（TAB分隔）';
                }
            }).catch((error) => {
                console.error('Failed to export config:', error);
                alert('配置导出失败，请手动复制。');
            });
        }

        function exportToClipboard() {
            const boardData = getBoardData();
            const boardStr = JSON.stringify(boardData);

            navigator.clipboard.writeText(boardStr).then(() => {
                const btn = document.getElementById('btnExportSingle');
                if (btn) {
                    btn.style.background = 'rgba(150, 150, 150, 0.6)';
                    btn.style.cursor = 'pointer';
                }
            }).catch(() => {
                alert('复制失败，请手动复制');
            });
        }

        function normalizeImportedBoardMatrix(rawBoardData) {
            if (!Array.isArray(rawBoardData) || rawBoardData.length === 0) return null;
            if (!Array.isArray(rawBoardData[0]) || rawBoardData[0].length === 0) return null;
            const width = rawBoardData[0].length;
            const normalized = [];
            for (const row of rawBoardData) {
                if (!Array.isArray(row) || row.length !== width) return null;
                const normalizedRow = row.map((value) => {
                    const numericValue = Number(value);
                    if (!Number.isFinite(numericValue)) return EMPTY_CELL_ID;
                    return Math.trunc(numericValue);
                });
                normalized.push(normalizedRow);
            }
            return normalized;
        }

        function extractBoardFromParsedClipboardData(parsedData) {
            if (Array.isArray(parsedData)) {
                if (parsedData.length > 0 && Array.isArray(parsedData[0])) {
                    return parsedData;
                }
                if (parsedData.length > 0 && parsedData[0] && typeof parsedData[0] === 'object') {
                    const firstItem = parsedData[0];
                    if (Array.isArray(firstItem.zhenxing)) return firstItem.zhenxing;
                    if (Array.isArray(firstItem.board)) return firstItem.board;
                }
            }
            if (parsedData && typeof parsedData === 'object') {
                if (Array.isArray(parsedData.zhenxing)) return parsedData.zhenxing;
                if (Array.isArray(parsedData.board)) return parsedData.board;
                if (Array.isArray(parsedData.levels) && parsedData.levels.length > 0) {
                    const firstLevel = parsedData.levels[0];
                    if (firstLevel && Array.isArray(firstLevel.zhenxing)) return firstLevel.zhenxing;
                    if (firstLevel && Array.isArray(firstLevel.board)) return firstLevel.board;
                }
            }
            return null;
        }

        function parseBoardFromClipboardText(clipboardText) {
            if (typeof clipboardText !== 'string') return null;
            const text = clipboardText.trim();
            if (!text) return null;

            const tryParseJson = (jsonText) => {
                try {
                    const parsed = JSON.parse(jsonText);
                    return extractBoardFromParsedClipboardData(parsed);
                } catch (_) {
                    return null;
                }
            };

            const directParsed = tryParseJson(text);
            if (directParsed) return directParsed;

            const tabSegments = text.split('\t');
            for (const segment of tabSegments) {
                const candidate = tryParseJson(segment.trim());
                if (candidate) return candidate;
            }

            const arrayStart = text.indexOf('[[');
            const arrayEnd = text.lastIndexOf(']]');
            if (arrayStart !== -1 && arrayEnd !== -1 && arrayEnd > arrayStart) {
                const candidateText = text.slice(arrayStart, arrayEnd + 2);
                const candidate = tryParseJson(candidateText);
                if (candidate) return candidate;
            }
            return null;
        }

        async function importBoardFromClipboard() {
            if (isSimulatingPlayGames || isBatchCampaignRunning || isBatchGenerating) {
                alert('当前有任务进行中，请稍后再试。');
                return;
            }
            if (!navigator.clipboard || typeof navigator.clipboard.readText !== 'function') {
                alert('当前环境不支持读取剪贴板。');
                return;
            }

            let clipboardText = '';
            try {
                clipboardText = await navigator.clipboard.readText();
            } catch (error) {
                console.error('Failed to read clipboard:', error);
                alert('读取剪贴板失败，请检查浏览器权限。');
                return;
            }

            const parsedBoard = parseBoardFromClipboardText(clipboardText);
            const boardData = normalizeImportedBoardMatrix(parsedBoard);
            if (!boardData) {
                alert('剪贴板中未找到有效阵型数据。');
                return;
            }
            const loaded = loadBoardDataIntoEditor(boardData);
            if (!loaded) return;

            const info = document.getElementById('info');
            if (info) info.textContent = `已读取阵型：${boardData[0].length}×${boardData.length}`;
        }

        function loadBoardDataIntoEditor(boardData) {
            const normalizedBoard = normalizeImportedBoardMatrix(boardData);
            if (!normalizedBoard) {
                alert('阵型数据无效。');
                return false;
            }
            const height = normalizedBoard.length;
            const width = normalizedBoard[0].length;
            if (!isSupportedBoardSize(width, height)) {
                alert('读取失败：阵型尺寸仅支持 6×8、8×10、10×12。');
                return false;
            }

            const specKey = resolveBoardSizeSpecFromDimensions(width, height);
            setBoardSizeSpec(specKey, { refreshPool: false, refreshInfo: false });
            calculatePool();
            generateBoard();

            filledCells = cloneBoardData(normalizedBoard);
            syncBoardDisplayByData(filledCells);
            updateResultSummaryByBoard(filledCells);
            updateLevelStats(getCurrentDirectionValue());
            setTimeout(scaleBoard, 100);
            return true;
        }

        function getNextSavedLevelId() {
            if (!Array.isArray(savedLevels) || savedLevels.length === 0) return 1;
            let maxId = 0;
            for (const item of savedLevels) {
                const itemId = Number(item?.id);
                if (Number.isFinite(itemId) && itemId > maxId) {
                    maxId = Math.floor(itemId);
                }
            }
            return maxId + 1;
        }

        function renumberSavedLevelIdsByOrder() {
            if (!Array.isArray(savedLevels)) return;
            for (let index = 0; index < savedLevels.length; index++) {
                const item = savedLevels[index];
                if (!item || typeof item !== 'object') continue;
                item.id = index + 1;
            }
        }

        function getSavedLevelSpecialIconPath(specialKey) {
            if (specialKey === 'bomb') {
                return 'img/zhadan.png';
            }
            if (specialKey === `attachment-${ATTACHMENT_FANPAI_ID}`) {
                return getAttachmentImagePath(ATTACHMENT_FANPAI_ID);
            }
            if (specialKey === `attachment-${ATTACHMENT_ICESHELL_ID}`) {
                return getAttachmentImagePath(ATTACHMENT_ICESHELL_ID);
            }
            if (String(specialKey).startsWith('obstacle-')) {
                const obstacleId = parseInt(String(specialKey).slice(9), 10);
                if (Number.isFinite(obstacleId)) return getObstacleImagePath(obstacleId);
            }
            return '';
        }

        function getSavedLevelSpecialTitle(specialKey) {
            const titleMap = {
                bomb: '火箭',
                [`attachment-${ATTACHMENT_FANPAI_ID}`]: '翻牌附着',
                [`attachment-${ATTACHMENT_ICESHELL_ID}`]: '冰壳附着',
                [`obstacle-${STONE_CELL_ID}`]: '石头',
                [`obstacle-${WOOD_CELL_ID}`]: '木块',
                [`obstacle-${ICE_LEVEL_1_CELL_ID}`]: '冰块1',
                [`obstacle-${ICE_LEVEL_2_CELL_ID}`]: '冰块2',
                [`obstacle-${ICE_LEVEL_3_CELL_ID}`]: '冰块3'
            };
            return titleMap[specialKey] || `ID:${specialKey}`;
        }

        function collectSavedLevelSpecialBaseIds(boardData) {
            const usedKeys = new Set();
            if (!Array.isArray(boardData)) return [];
            for (const row of boardData) {
                if (!Array.isArray(row)) continue;
                for (const rawId of row) {
                    const parsed = decodeCellId(rawId);
                    if (parsed.baseId === BOMB_CELL_ID) {
                        usedKeys.add('bomb');
                    }
                    if (isObstacleBaseId(parsed.baseId)) {
                        usedKeys.add(`obstacle-${parsed.baseId}`);
                    }
                    if (parsed.hasAttachment && ATTACHMENT_IDS.has(parsed.attachmentId)) {
                        usedKeys.add(`attachment-${parsed.attachmentId}`);
                    }
                }
            }
            const preferredOrder = [
                'bomb',
                `attachment-${ATTACHMENT_FANPAI_ID}`,
                `attachment-${ATTACHMENT_ICESHELL_ID}`,
                `obstacle-${STONE_CELL_ID}`,
                `obstacle-${WOOD_CELL_ID}`,
                `obstacle-${ICE_LEVEL_1_CELL_ID}`,
                `obstacle-${ICE_LEVEL_2_CELL_ID}`,
                `obstacle-${ICE_LEVEL_3_CELL_ID}`
            ];
            const ordered = preferredOrder.filter((key) => usedKeys.has(key));
            usedKeys.forEach((key) => {
                if (!ordered.includes(key)) ordered.push(key);
            });
            return ordered;
        }

        function normalizeBoardForSavedLevel(boardData) {
            const normalizedBoard = normalizeImportedBoardMatrix(boardData);
            if (!normalizedBoard) return null;
            return normalizedBoard.map((row) => row.map((rawId) => {
                const parsed = decodeCellId(rawId);
                if (isEmptyCellId(parsed.baseId)) return EMPTY_CELL_ID;
                if (isObstacleBaseId(parsed.baseId)) return parsed.baseId;

                // 保存阵型时，花色牌统一保存为占位块；附着关系保留
                if (parsed.baseId >= 1 && parsed.baseId <= 98) {
                    if (parsed.hasAttachment && ATTACHMENT_IDS.has(parsed.attachmentId)) {
                        return encodeAttachedCellId(PLACEHOLDER_CELL_ID, parsed.attachmentId);
                    }
                    return PLACEHOLDER_CELL_ID;
                }

                // 炸弹等特殊可消块保持原样
                if (parsed.hasAttachment && ATTACHMENT_IDS.has(parsed.attachmentId)) {
                    return encodeAttachedCellId(parsed.baseId, parsed.attachmentId);
                }
                return parsed.baseId;
            }));
        }

        function getSavedLevelPreviewImagePath(baseId) {
            if (baseId === PLACEHOLDER_CELL_ID) return 'img/base.png';
            if (isObstacleBaseId(baseId)) return getObstacleImagePath(baseId);
            if (baseId === BOMB_CELL_ID) return 'img/zhadan.png';
            if (baseId >= 1 && baseId <= 98) {
                const imageIndex = ((baseId - 1) % 34) + 1;
                return `img/${imageIndex}.png`;
            }
            return '';
        }

        function getBoardCellAspectRatioForPreview() {
            const fallbackWidth = 150;
            const fallbackHeight = 150;
            const firstCell = document.getElementById('cell-0-0');
            if (!firstCell) {
                return {
                    width: fallbackWidth,
                    height: fallbackHeight,
                    ratio: fallbackHeight / fallbackWidth
                };
            }
            const rect = firstCell.getBoundingClientRect();
            const width = rect.width > 0 ? rect.width : fallbackWidth;
            const height = rect.height > 0 ? rect.height : fallbackHeight;
            return {
                width,
                height,
                ratio: height / width
            };
        }

        function moveSavedLevelPreview(clientX, clientY) {
            const preview = document.getElementById('savedLevelPreview');
            if (!preview || !preview.classList.contains('visible')) return;
            const offset = 14;
            const viewportWidth = window.innerWidth || 0;
            const viewportHeight = window.innerHeight || 0;
            const previewWidth = preview.offsetWidth || 220;
            const previewHeight = preview.offsetHeight || 140;
            const left = Math.min(
                Math.max(0, clientX + offset),
                Math.max(0, viewportWidth - previewWidth - 8)
            );
            const top = Math.min(
                Math.max(0, clientY + offset),
                Math.max(0, viewportHeight - previewHeight - 8)
            );
            preview.style.left = `${left}px`;
            preview.style.top = `${top}px`;
        }

        function hideSavedLevelPreview() {
            const preview = document.getElementById('savedLevelPreview');
            if (!preview) return;
            preview.classList.remove('visible');
            preview.innerHTML = '';
        }

        function showSavedLevelPreview(index, clientX, clientY) {
            const preview = document.getElementById('savedLevelPreview');
            const savedItem = savedLevels[index];
            if (!preview || !savedItem || !Array.isArray(savedItem.boardData)) return;

            const rowCount = savedItem.boardData.length;
            const colCount = savedItem.boardData[0]?.length || 0;
            if (!rowCount || !colCount) return;

            preview.innerHTML = '';
            const header = document.createElement('div');
            header.className = 'saved-level-preview-header';
            header.textContent = `#${savedItem.id}  ${colCount}×${rowCount}`;
            preview.appendChild(header);

            const board = document.createElement('div');
            board.className = 'saved-level-preview-board';
            const safeColCount = Math.max(1, colCount);
            const safeRowCount = Math.max(1, rowCount);
            const maxPreviewBoardWidth = 260;
            const maxPreviewBoardHeight = 220;
            const boardCellSize = getBoardCellAspectRatioForPreview();
            const ratio = boardCellSize.ratio > 0 ? boardCellSize.ratio : 1;
            const widthByCols = Math.floor((maxPreviewBoardWidth / safeColCount) - 1);
            const widthByRows = Math.floor((maxPreviewBoardHeight / safeRowCount) / ratio);
            const cellWidth = Math.max(10, Math.min(18, Math.min(widthByCols, widthByRows)));
            const cellHeight = Math.max(10, Math.round(cellWidth * ratio));
            board.style.gridTemplateColumns = `repeat(${safeColCount}, ${cellWidth}px)`;
            const previewScale = Math.min(cellWidth / 150, cellHeight / 150);
            board.style.setProperty('--preview-scale', previewScale.toFixed(4));

            for (const row of savedItem.boardData) {
                for (const rawId of row) {
                    const parsed = decodeCellId(rawId);
                    const cell = document.createElement('div');
                    cell.className = 'saved-level-preview-cell';
                    cell.style.width = `${cellWidth}px`;
                    cell.style.height = `${cellHeight}px`;
                    if (isEmptyCellId(parsed.baseId)) {
                        cell.classList.add('is-empty');
                        board.appendChild(cell);
                        continue;
                    }

                    if (isObstacleBaseId(parsed.baseId)) {
                        const obstaclePath = getObstacleImagePath(parsed.baseId);
                        if (obstaclePath) {
                            const obstacleImage = document.createElement('img');
                            obstacleImage.className = 'saved-level-preview-obstacle';
                            if (
                                parsed.baseId === STONE_CELL_ID ||
                                parsed.baseId === WOOD_CELL_ID ||
                                parsed.baseId === ICE_LEVEL_1_CELL_ID ||
                                parsed.baseId === ICE_LEVEL_2_CELL_ID ||
                                parsed.baseId === ICE_LEVEL_3_CELL_ID
                            ) {
                                obstacleImage.classList.add('saved-level-preview-obstacle-scale130');
                            }
                            obstacleImage.src = obstaclePath;
                            obstacleImage.alt = '';
                            cell.appendChild(obstacleImage);
                        }
                        board.appendChild(cell);
                        continue;
                    }

                    const stack = document.createElement('div');
                    stack.className = 'saved-level-preview-stack';

                    const baseImage = document.createElement('img');
                    baseImage.className = 'saved-level-preview-base';
                    baseImage.src = 'img/base.png';
                    baseImage.alt = '';
                    stack.appendChild(baseImage);

                    if (parsed.baseId !== PLACEHOLDER_CELL_ID) {
                        const facePath = getSavedLevelPreviewImagePath(parsed.baseId);
                        if (facePath) {
                            const faceImage = document.createElement('img');
                            faceImage.className = 'saved-level-preview-face';
                            if (parsed.baseId === BOMB_CELL_ID) {
                                faceImage.classList.add('saved-level-preview-face-bomb');
                            }
                            faceImage.src = facePath;
                            faceImage.alt = '';
                            stack.appendChild(faceImage);
                        }
                    }

                    if (parsed.hasAttachment && ATTACHMENT_IDS.has(parsed.attachmentId)) {
                        const attachmentPath = getAttachmentImagePath(parsed.attachmentId);
                        if (attachmentPath) {
                            const attachmentImage = document.createElement('img');
                            attachmentImage.className = 'saved-level-preview-attachment';
                            if (parsed.attachmentId === ATTACHMENT_FANPAI_ID) {
                                attachmentImage.classList.add('saved-level-preview-attachment-fanpai');
                            } else if (parsed.attachmentId === ATTACHMENT_ICESHELL_ID) {
                                attachmentImage.classList.add('saved-level-preview-attachment-iceshell');
                            }
                            attachmentImage.src = attachmentPath;
                            attachmentImage.alt = '';
                            stack.appendChild(attachmentImage);
                        }
                    }

                    cell.appendChild(stack);
                    board.appendChild(cell);
                }
            }

            preview.appendChild(board);
            preview.classList.add('visible');
            moveSavedLevelPreview(clientX, clientY);
        }

        function updateSaveCurrentLevelButtonState() {
            const saveButton = document.getElementById('btnSaveCurrentLevel');
            if (!saveButton) return;
            const isEditingMode = editingSavedLevelIndex >= 0;
            saveButton.disabled = isEditingMode;
            saveButton.title = isEditingMode
                ? '当前处于编辑模式，请使用关卡列表中的“保存”按钮'
                : '';
        }

        function resetSavedLevelEditState() {
            editingSavedLevelIndex = -1;
            editingSavedLevelSnapshot = null;
            updateSaveCurrentLevelButtonState();
        }

        function beginSavedLevelEdit(index) {
            if (index < 0 || index >= savedLevels.length) return;
            if (editingSavedLevelIndex !== -1 && editingSavedLevelIndex !== index) {
                alert('请先保存或取消当前编辑关卡。');
                return;
            }
            const savedItem = savedLevels[index];
            if (!savedItem) return;
            closeSavedLevelContextMenu();
            const loaded = loadBoardDataIntoEditor(savedItem.boardData);
            if (!loaded) return;

            editingSavedLevelIndex = index;
            editingSavedLevelSnapshot = {
                index,
                boardData: cloneBoardData(savedItem.boardData)
            };
            updateSaveCurrentLevelButtonState();
            renderSavedLevelList();
            setInfoText(`已进入编辑：关卡 #${savedItem.id}（保存/取消）`);
        }

        function saveEditingSavedLevel() {
            if (editingSavedLevelIndex < 0 || editingSavedLevelIndex >= savedLevels.length) return;
            const boardData = normalizeBoardForSavedLevel(getBoardData());
            if (!boardData) {
                alert('当前棋盘无可保存数据。');
                return;
            }
            const currentItem = savedLevels[editingSavedLevelIndex];
            if (!currentItem) {
                resetSavedLevelEditState();
                renderSavedLevelList();
                return;
            }
            savedLevels[editingSavedLevelIndex] = {
                ...currentItem,
                boardData: cloneBoardData(boardData)
            };
            const savedId = currentItem.id;
            resetSavedLevelEditState();
            renderSavedLevelList();
            setInfoText(`已保存编辑：关卡 #${savedId}`);
        }

        function cancelSavedLevelEdit() {
            if (editingSavedLevelIndex < 0) return;
            const snapshot = editingSavedLevelSnapshot
                ? {
                    boardData: cloneBoardData(editingSavedLevelSnapshot.boardData)
                }
                : null;
            const editingItem = savedLevels[editingSavedLevelIndex];
            const editingLevelId = editingItem?.id;
            resetSavedLevelEditState();
            renderSavedLevelList();
            if (snapshot && Array.isArray(snapshot.boardData)) {
                loadBoardDataIntoEditor(snapshot.boardData);
            }
            if (Number.isFinite(Number(editingLevelId))) {
                setInfoText(`已取消编辑：关卡 #${editingLevelId}`);
            } else {
                setInfoText('已取消编辑');
            }
        }

        function renderSavedLevelList() {
            closeSavedLevelContextMenu();
            hideSavedLevelPreview();
            updateSaveCurrentLevelButtonState();
            const listContainer = document.getElementById('savedLevelList');
            if (!listContainer) return;
            listContainer.innerHTML = '';

            if (!Array.isArray(savedLevels) || savedLevels.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'saved-level-empty';
                empty.textContent = '暂无保存关卡。点击“保存本关”可加入列表。';
                listContainer.appendChild(empty);
                return;
            }

            savedLevels.forEach((item, index) => {
                const rowCount = item?.boardData?.length || 0;
                const colCount = item?.boardData?.[0]?.length || 0;
                const specialIds = collectSavedLevelSpecialBaseIds(item?.boardData);
                const itemElement = document.createElement('div');
                itemElement.className = 'saved-level-item';
                itemElement.dataset.index = String(index);

                const isEditingItem = editingSavedLevelIndex === index;
                if (isEditingItem) {
                    itemElement.classList.add('saved-level-item-editing');
                    const editActions = document.createElement('div');
                    editActions.className = 'saved-level-item-edit-actions';

                    const saveButton = document.createElement('button');
                    saveButton.type = 'button';
                    saveButton.className = 'btn-primary';
                    saveButton.textContent = '保存';
                    saveButton.onclick = (event) => {
                        event.stopPropagation();
                        saveEditingSavedLevel();
                    };

                    const cancelButton = document.createElement('button');
                    cancelButton.type = 'button';
                    cancelButton.className = 'btn-secondary';
                    cancelButton.textContent = '取消';
                    cancelButton.onclick = (event) => {
                        event.stopPropagation();
                        cancelSavedLevelEdit();
                    };

                    editActions.appendChild(saveButton);
                    editActions.appendChild(cancelButton);
                    itemElement.appendChild(editActions);
                    listContainer.appendChild(itemElement);
                    return;
                }

                const mainRow = document.createElement('div');
                mainRow.className = 'saved-level-item-main';

                const leftInfo = document.createElement('div');
                leftInfo.className = 'saved-level-item-left';

                const idLine = document.createElement('div');
                idLine.className = 'saved-level-item-id';
                idLine.textContent = `#${item.id}`;
                const metaLine = document.createElement('div');
                metaLine.className = 'saved-level-item-meta';
                const metaText = document.createElement('span');
                metaText.textContent = `${colCount}×${rowCount}`;
                metaLine.appendChild(metaText);
                leftInfo.appendChild(idLine);
                leftInfo.appendChild(metaLine);
                mainRow.appendChild(leftInfo);

                const iconRow = document.createElement('div');
                iconRow.className = 'saved-level-item-icons';

                specialIds.forEach((baseId) => {
                    const iconPath = getSavedLevelSpecialIconPath(baseId);
                    if (!iconPath) return;
                    const icon = document.createElement('img');
                    icon.className = 'saved-level-item-icon';
                    icon.src = iconPath;
                    icon.alt = getSavedLevelSpecialTitle(baseId);
                    icon.title = getSavedLevelSpecialTitle(baseId);
                    iconRow.appendChild(icon);
                });

                mainRow.appendChild(iconRow);
                itemElement.appendChild(mainRow);

                itemElement.onclick = () => {
                    hideSavedLevelPreview();
                    applySavedLevelByIndex(index);
                };
                itemElement.oncontextmenu = (event) => {
                    hideSavedLevelPreview();
                    openSavedLevelContextMenu(event, index);
                };
                itemElement.onmouseenter = (event) => {
                    showSavedLevelPreview(index, event.clientX, event.clientY);
                };
                itemElement.onmousemove = (event) => {
                    moveSavedLevelPreview(event.clientX, event.clientY);
                };
                itemElement.onmouseleave = () => {
                    hideSavedLevelPreview();
                };
                listContainer.appendChild(itemElement);
            });
        }

        function applySavedLevelByIndex(index) {
            if (index < 0 || index >= savedLevels.length) return;
            if (editingSavedLevelIndex !== -1 && editingSavedLevelIndex !== index) {
                alert('请先保存或取消当前编辑关卡。');
                return;
            }
            const savedItem = savedLevels[index];
            if (!savedItem) return;
            const loaded = loadBoardDataIntoEditor(savedItem.boardData);
            if (!loaded) return;
            setInfoText(`已应用关卡 #${savedItem.id} 到棋盘`);
        }

        function saveCurrentLevelToList() {
            if (editingSavedLevelIndex >= 0) {
                alert('当前处于编辑模式，请使用关卡列表中的“保存”按钮。');
                return;
            }
            if (isSimulatingPlayGames || isBatchCampaignRunning || isBatchGenerating) {
                alert('当前有任务进行中，请稍后再试。');
                return;
            }
            const boardData = normalizeBoardForSavedLevel(getBoardData());
            if (!boardData) {
                alert('当前棋盘无可保存数据。');
                return;
            }
            const levelEntry = {
                id: getNextSavedLevelId(),
                boardData: cloneBoardData(boardData)
            };
            savedLevels.push(levelEntry);
            renderSavedLevelList();
            setInfoText(`已保存关卡 #${levelEntry.id}`);
        }

        function deleteSavedLevelByIndex(index) {
            if (index < 0 || index >= savedLevels.length) return;
            const removed = savedLevels.splice(index, 1);
            const removedId = Number(removed?.[0]?.id);
            if (editingSavedLevelIndex === index) {
                resetSavedLevelEditState();
            } else if (editingSavedLevelIndex > index) {
                editingSavedLevelIndex -= 1;
            }
            renumberSavedLevelIdsByOrder();
            renderSavedLevelList();
            if (Number.isFinite(removedId)) {
                setInfoText(`已删除关卡 #${removedId}，其后关卡序号已顺延`);
            }
        }

        function moveSavedLevelToOrder(index, targetOrder) {
            if (index < 0 || index >= savedLevels.length) return;
            const clampedOrder = Math.max(1, Math.min(savedLevels.length, targetOrder));
            const targetIndex = clampedOrder - 1;
            if (targetIndex === index) return;
            const [movedItem] = savedLevels.splice(index, 1);
            savedLevels.splice(targetIndex, 0, movedItem);
            if (editingSavedLevelIndex === index) {
                editingSavedLevelIndex = targetIndex;
                if (editingSavedLevelSnapshot) editingSavedLevelSnapshot.index = targetIndex;
            } else if (editingSavedLevelIndex > index && editingSavedLevelIndex <= targetIndex) {
                editingSavedLevelIndex -= 1;
                if (editingSavedLevelSnapshot) editingSavedLevelSnapshot.index = editingSavedLevelIndex;
            } else if (editingSavedLevelIndex < index && editingSavedLevelIndex >= targetIndex) {
                editingSavedLevelIndex += 1;
                if (editingSavedLevelSnapshot) editingSavedLevelSnapshot.index = editingSavedLevelIndex;
            }
            renumberSavedLevelIdsByOrder();
            renderSavedLevelList();
        }

        function openSavedLevelContextMenu(event, index) {
            event.preventDefault();
            hideSavedLevelPreview();
            const contextMenu = document.getElementById('savedLevelContextMenu');
            if (!contextMenu) return;
            savedLevelContextIndex = index;
            contextMenu.classList.add('visible');
            const viewportWidth = window.innerWidth || 0;
            const viewportHeight = window.innerHeight || 0;
            const menuWidth = 140;
            const menuHeight = 132;
            const left = Math.min(Math.max(0, event.clientX), Math.max(0, viewportWidth - menuWidth - 6));
            const top = Math.min(Math.max(0, event.clientY), Math.max(0, viewportHeight - menuHeight - 6));
            contextMenu.style.left = `${left}px`;
            contextMenu.style.top = `${top}px`;
        }

        function closeSavedLevelContextMenu() {
            const contextMenu = document.getElementById('savedLevelContextMenu');
            if (!contextMenu) return;
            contextMenu.classList.remove('visible');
            savedLevelContextIndex = -1;
        }

        function handleSavedLevelContextAction(action) {
            const index = savedLevelContextIndex;
            if (index < 0 || index >= savedLevels.length) {
                closeSavedLevelContextMenu();
                return;
            }
            if (action === 'edit' || action === 'read') {
                beginSavedLevelEdit(index);
                closeSavedLevelContextMenu();
                return;
            }
            if (action === 'delete') {
                deleteSavedLevelByIndex(index);
                closeSavedLevelContextMenu();
                return;
            }
            if (action === 'reorder') {
                const rawInput = prompt('请输入新的序号（从1开始）', String(index + 1));
                if (rawInput !== null) {
                    const targetOrder = parseInt(rawInput, 10);
                    if (Number.isFinite(targetOrder)) {
                        moveSavedLevelToOrder(index, targetOrder);
                    }
                }
                closeSavedLevelContextMenu();
            }
        }

        async function triggerImportSavedLevels() {
            if (isBatchCampaignRunning || isBatchGenerating || isSimulatingPlayGames) {
                alert('当前有任务进行中，请稍后再试。');
                return;
            }
            if (typeof window.showOpenFilePicker === 'function') {
                try {
                    const [fileHandle] = await window.showOpenFilePicker({
                        multiple: false,
                        types: [
                            {
                                description: '关卡列表',
                                accept: {
                                    'text/plain': ['.txt'],
                                    'application/json': ['.json']
                                }
                            }
                        ]
                    });
                    if (!fileHandle) return;
                    await importSavedLevelsFromFileHandle(fileHandle);
                    return;
                } catch (error) {
                    if (error?.name === 'AbortError') return;
                    console.error('Failed to import saved levels via picker:', error);
                }
            }
            const input = document.getElementById('savedLevelFileInput');
            if (!input) return;
            input.value = '';
            input.click();
        }

        function parseSavedLevelsFromText(text) {
            const result = [];
            if (typeof text !== 'string') return result;
            const trimmed = text.trim();
            if (!trimmed) return result;

            const tryParseJsonArray = () => {
                try {
                    const parsed = JSON.parse(trimmed);
                    if (!Array.isArray(parsed)) return;
                    for (const entry of parsed) {
                        const rawBoard = Array.isArray(entry?.zhenxing) ? entry.zhenxing : entry?.boardData;
                        const boardData = normalizeImportedBoardMatrix(rawBoard);
                        if (!boardData) continue;
                        const rawId = Number(entry?.id ?? entry?.level);
                        const id = Number.isFinite(rawId) ? Math.max(1, Math.floor(rawId)) : null;
                        result.push({ id, boardData });
                    }
                } catch (_) {}
            };

            tryParseJsonArray();
            if (result.length > 0) return result;

            const lines = trimmed.split(/\r?\n/).map((line) => line.trim()).filter(Boolean);
            for (const line of lines) {
                const columns = line.split('\t');
                if (columns.length < 2) continue;
                const idText = columns[0].trim();
                const boardText = columns[1].trim();
                let parsedBoard = null;
                try {
                    parsedBoard = JSON.parse(boardText);
                } catch (_) {
                    parsedBoard = null;
                }
                const boardData = normalizeImportedBoardMatrix(parsedBoard);
                if (!boardData) continue;
                const rawId = Number(idText);
                const id = Number.isFinite(rawId) ? Math.max(1, Math.floor(rawId)) : null;
                result.push({ id, boardData });
            }
            return result;
        }

        function normalizeSavedLevelsForList(parsedItems) {
            const normalized = [];
            const usedIds = new Set();
            let nextId = 1;
            for (const item of parsedItems) {
                let id = Number.isFinite(Number(item.id)) ? Math.floor(Number(item.id)) : null;
                if (!id || id <= 0 || usedIds.has(id)) {
                    while (usedIds.has(nextId)) nextId++;
                    id = nextId;
                }
                usedIds.add(id);
                normalized.push({
                    id,
                    boardData: cloneBoardData(item.boardData)
                });
            }
            return normalized;
        }

        function applyImportedSavedLevels(parsedItems, sourceName = '') {
            if (!Array.isArray(parsedItems) || parsedItems.length === 0) {
                alert('读取失败：文件中没有有效关卡。');
                return false;
            }
            savedLevels = normalizeSavedLevelsForList(parsedItems);
            resetSavedLevelEditState();
            renderSavedLevelList();
            const suffix = sourceName ? `（${sourceName}）` : '';
            setInfoText(`已读取关卡列表${suffix}：${savedLevels.length} 关`);
            return true;
        }

        function buildSavedLevelsTextContent() {
            let content = '';
            savedLevels.forEach((item) => {
                content += `${item.id}\t${JSON.stringify(item.boardData)}\n`;
            });
            return content;
        }

        async function saveSavedLevelsToCurrentFile() {
            if (!Array.isArray(savedLevels) || savedLevels.length === 0) {
                alert('列表为空，暂无可保存关卡。');
                return;
            }
            if (!savedLevelFileHandle) {
                alert('当前未绑定可覆盖保存文件，请先通过“读取”选择文件，或使用“导出”另存为。');
                return;
            }
            try {
                if (typeof savedLevelFileHandle.requestPermission === 'function') {
                    const permission = await savedLevelFileHandle.requestPermission({
                        mode: 'readwrite'
                    });
                    if (permission !== 'granted') {
                        alert('未获得文件写入权限，无法保存。');
                        return;
                    }
                }
                const writable = await savedLevelFileHandle.createWritable();
                await writable.write(buildSavedLevelsTextContent());
                await writable.close();
                const displayName = savedLevelSourceFileName || '当前文件';
                setInfoText(`已保存关卡列表到：${displayName}`);
            } catch (error) {
                console.error('Failed to save saved levels file:', error);
                alert('保存失败，请重试。');
            }
        }

        function exportSavedLevels() {
            if (!Array.isArray(savedLevels) || savedLevels.length === 0) {
                alert('列表为空，暂无可导出关卡。');
                return;
            }
            const content = buildSavedLevelsTextContent();
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `关卡列表_${savedLevels.length}关.txt`;
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 0);
        }

        async function importSavedLevelsFromFileHandle(fileHandle) {
            if (!fileHandle) return;
            const file = await fileHandle.getFile();
            const text = await file.text();
            const parsedItems = parseSavedLevelsFromText(text);
            const applied = applyImportedSavedLevels(parsedItems, file.name || '');
            if (!applied) return;
            savedLevelFileHandle = fileHandle;
            savedLevelSourceFileName = file.name || '';
        }

        function handleSavedLevelFileChange(event) {
            const input = event?.target || document.getElementById('savedLevelFileInput');
            const file = event?.target?.files?.[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const text = typeof reader.result === 'string' ? reader.result : '';
                    const parsedItems = parseSavedLevelsFromText(text);
                    applyImportedSavedLevels(parsedItems, file.name || '');
                    savedLevelFileHandle = null;
                    savedLevelSourceFileName = file.name || '';
                } catch (error) {
                    console.error('Failed to import saved levels:', error);
                    alert('读取失败，请检查文件格式。');
                } finally {
                    if (input) input.value = '';
                }
            };
            reader.onerror = () => {
                alert('读取文件失败，请重试。');
                if (input) input.value = '';
            };
            reader.readAsText(file, 'utf-8');
        }

        function getBoardData() {
            const { width, height } = getCurrentBoardDimensions();
            const data = [];
            for (let i = 0; i < height; i++) {
                const row = [];
                for (let j = 0; j < width; j++) {
                    row.push(filledCells[i]?.[j] ?? 0);
                }
                data.push(row);
            }
            return data;
        }

        function generateSingleLevel(
            direction,
            sameLie,
            sameNum,
            xianglinSame,
            directionBothCtrl,
            distanceCtrl
        ) {
            const { width, height } = getCurrentBoardDimensions();

            currentPool = [];
            poolCards = [];
            calculatePoolForGenerate(width, height);

            const fillOrder = getFillOrder(width, height, direction);
            filledCells = [];

            for (let i = 0; i < height; i++) {
                filledCells[i] = [];
                for (let j = 0; j < width; j++) {
                    filledCells[i][j] = null;
                }
            }

            placedCounts = {};
            currentPool.forEach(item => {
                placedCounts[item.number] = 0;
            });

            for (let idx = 0; idx < fillOrder.length; idx++) {
                const {i, j, prevI, prevJ, firstInGroup, groupCol, groupRow} = fillOrder[idx];
                let num = null;
                const isRowDirection = isRowBaseDirection(direction);

                const hasPoolNumber = (targetNumber) => {
                    const poolItem = currentPool.find(p => p.number === targetNumber);
                    return !!poolItem && placedCounts[targetNumber] < poolItem.count;
                };

                const getGroupUsedNumbers = () => {
                    const usedInGroup = new Set();
                    if (isRowDirection) {
                        for (let jj = 0; jj < width; jj++) {
                            if (filledCells[i]?.[jj] !== null && filledCells[i]?.[jj] !== undefined) {
                                usedInGroup.add(filledCells[i][jj]);
                            }
                        }
                    } else {
                        for (let ii = 0; ii < height; ii++) {
                            if (filledCells[ii]?.[j] !== null && filledCells[ii]?.[j] !== undefined) {
                                usedInGroup.add(filledCells[ii][j]);
                            }
                        }
                    }
                    return usedInGroup;
                };

                const pickByGroupPreference = (preferUsed, forbiddenNumbers = new Set()) => {
                    const usedInGroup = getGroupUsedNumbers();
                    const candidates = [];
                    const allowedCandidates = [];
                    for (const poolItem of currentPool) {
                        const canUse = placedCounts[poolItem.number] < poolItem.count;
                        if (!canUse) continue;
                        const inGroup = usedInGroup.has(poolItem.number);
                        if ((preferUsed && inGroup) || (!preferUsed && !inGroup)) {
                            candidates.push(poolItem.number);
                            if (!forbiddenNumbers.has(poolItem.number)) {
                                allowedCandidates.push(poolItem.number);
                            }
                        }
                    }
                    if (candidates.length === 0) return null;
                    const source = allowedCandidates.length > 0 ? allowedCandidates : candidates;
                    const picked = chooseCandidateByControl(source);
                    if (picked === null) return null;
                    return picked;
                };

                const getAdjacentSamePositionCandidateNumbers = () => {
                    const adjacentCandidates = [];
                    if (isRowDirection) {
                        const upNum = i > 0 ? filledCells[i - 1]?.[j] : null;
                        const downNum = i < height - 1 ? filledCells[i + 1]?.[j] : null;
                        if (upNum !== null && upNum !== undefined) {
                            adjacentCandidates.push(upNum);
                        }
                        if (downNum !== null && downNum !== undefined) {
                            adjacentCandidates.push(downNum);
                        }
                    } else {
                        const leftNum = j > 0 ? filledCells[i]?.[j - 1] : null;
                        const rightNum = j < width - 1 ? filledCells[i]?.[j + 1] : null;
                        if (leftNum !== null && leftNum !== undefined) {
                            adjacentCandidates.push(leftNum);
                        }
                        if (rightNum !== null && rightNum !== undefined) {
                            adjacentCandidates.push(rightNum);
                        }
                    }
                    return adjacentCandidates;
                };

                const getAdjacentLineCandidateSet = () => {
                    const adjacentSet = new Set();
                    if (isRowDirection) {
                        const adjacentRows = [];
                        if (i > 0) adjacentRows.push(i - 1);
                        if (i < height - 1) adjacentRows.push(i + 1);
                        for (const rowIndex of adjacentRows) {
                            for (let colIndex = 0; colIndex < width; colIndex++) {
                                const value = filledCells[rowIndex]?.[colIndex];
                                if (value !== null && value !== undefined) {
                                    adjacentSet.add(value);
                                }
                            }
                        }
                    } else {
                        const adjacentCols = [];
                        if (j > 0) adjacentCols.push(j - 1);
                        if (j < width - 1) adjacentCols.push(j + 1);
                        for (const colIndex of adjacentCols) {
                            for (let rowIndex = 0; rowIndex < height; rowIndex++) {
                                const value = filledCells[rowIndex]?.[colIndex];
                                if (value !== null && value !== undefined) {
                                    adjacentSet.add(value);
                                }
                            }
                        }
                    }
                    return adjacentSet;
                };

                const getAroundNeighborCandidateSet = () => {
                    const aroundSet = new Set();
                    for (let di = -1; di <= 1; di++) {
                        for (let dj = -1; dj <= 1; dj++) {
                            if (di === 0 && dj === 0) continue;
                            const ni = i + di;
                            const nj = j + dj;
                            if (ni < 0 || ni >= height || nj < 0 || nj >= width) continue;
                            const value = filledCells[ni]?.[nj];
                            if (value !== null && value !== undefined) {
                                aroundSet.add(value);
                            }
                        }
                    }
                    return aroundSet;
                };

                const getDirectionBothCandidateSet = () => {
                    const localDirection = getLocalBaseDirectionByCell(direction, i, j, width, height);
                    const upperSet = collectDirectionalSideNumbers(
                        i,
                        j,
                        width,
                        height,
                        localDirection,
                        'top'
                    );
                    const lowerSet = collectDirectionalSideNumbers(
                        i,
                        j,
                        width,
                        height,
                        localDirection,
                        'bottom'
                    );
                    const bothSet = new Set();
                    upperSet.forEach((value) => {
                        if (lowerSet.has(value)) bothSet.add(value);
                    });
                    return bothSet;
                };

                const chooseCandidateByControl = (candidateNumbers) => {
                    if (!candidateNumbers || candidateNumbers.length === 0) return null;
                    const directionBothSet = getDirectionBothCandidateSet();

                    let bestScore = -Infinity;
                    let bestCandidates = [];
                    for (const candidate of candidateNumbers) {
                        const inDirectionBoth = directionBothSet.has(candidate);
                        const directionScore = inDirectionBoth ? directionBothCtrl : (1 - directionBothCtrl);
                        const score = directionScore;
                        if (score > bestScore) {
                            bestScore = score;
                            bestCandidates = [candidate];
                        } else if (score === bestScore) {
                            bestCandidates.push(candidate);
                        }
                    }
                    if (bestCandidates.length === 0) return null;
                    return bestCandidates[Math.floor(Math.random() * bestCandidates.length)];
                };

                const pickByCandidateNumbers = (candidateNumbers, forbiddenNumbers = new Set()) => {
                    if (!candidateNumbers || candidateNumbers.length === 0) return null;
                    const uniqueCandidates = [];
                    const seen = new Set();
                    for (const candidate of candidateNumbers) {
                        if (seen.has(candidate)) continue;
                        seen.add(candidate);
                        if (!hasPoolNumber(candidate)) continue;
                        uniqueCandidates.push(candidate);
                    }
                    if (uniqueCandidates.length === 0) return null;
                    const allowedCandidates = uniqueCandidates.filter(
                        candidate => !forbiddenNumbers.has(candidate)
                    );
                    if (allowedCandidates.length === 0) return null;
                    const source = allowedCandidates;
                    const picked = chooseCandidateByControl(source);
                    if (picked === null) return null;
                    return picked;
                };

                const pickAnyCard = (forbiddenNumbers = new Set()) => {
                    const candidates = [];
                    const allowedCandidates = [];
                    for (const poolItem of currentPool) {
                        const canUse = placedCounts[poolItem.number] < poolItem.count;
                        if (!canUse) continue;
                        candidates.push(poolItem.number);
                        if (!forbiddenNumbers.has(poolItem.number)) {
                            allowedCandidates.push(poolItem.number);
                        }
                    }
                    if (candidates.length === 0) return null;
                    const source = allowedCandidates.length > 0 ? allowedCandidates : candidates;
                    const picked = chooseCandidateByControl(source);
                    if (picked === null) return null;
                    return picked;
                };

                const adjacentSamePositionNumbers = getAdjacentSamePositionCandidateNumbers();
                const adjacentLineNumbers = Array.from(getAdjacentLineCandidateSet());
                const aroundNeighborNumbers = Array.from(getAroundNeighborCandidateSet());
                const forbiddenNumbers = new Set();
                const aroundNeighborNumberSet = new Set(aroundNeighborNumbers);

                const tryAdjacentLineSet = Math.random() < sameNum;
                if (!tryAdjacentLineSet) {
                    adjacentLineNumbers.forEach(value => forbiddenNumbers.add(value));
                }

                const trySamePosition = Math.random() < xianglinSame;
                if (trySamePosition) {
                    num = pickByCandidateNumbers(adjacentSamePositionNumbers, forbiddenNumbers);
                } else {
                    adjacentSamePositionNumbers.forEach(value => forbiddenNumbers.add(value));
                }

                if (num === null) {
                    if (tryAdjacentLineSet) {
                        num = pickByCandidateNumbers(adjacentLineNumbers, forbiddenNumbers);
                    }
                }

                if (num === null) {
                    const preferUsed = Math.random() < sameLie;
                    num = pickByGroupPreference(preferUsed, forbiddenNumbers);
                    if (num === null) {
                        num = pickByGroupPreference(!preferUsed, forbiddenNumbers);
                    }
                }

                if (num === null) {
                    num = pickAnyCard(forbiddenNumbers);
                }

                if (num === null) {
                    num = getNextCard();
                }

                if (num !== null) {
                    if (aroundNeighborNumberSet.has(num) && Math.random() >= distanceCtrl) {
                        const replaceForbiddenNumbers = new Set(forbiddenNumbers);
                        aroundNeighborNumberSet.forEach(value => replaceForbiddenNumbers.add(value));
                        const preferUsedForReplace = Math.random() < sameLie;
                        let replacement = pickByGroupPreference(
                            preferUsedForReplace,
                            replaceForbiddenNumbers
                        );
                        if (replacement === null) {
                            replacement = pickByGroupPreference(
                                !preferUsedForReplace,
                                replaceForbiddenNumbers
                            );
                        }
                        if (replacement === null && tryAdjacentLineSet) {
                            replacement = pickByCandidateNumbers(
                                adjacentLineNumbers,
                                replaceForbiddenNumbers
                            );
                        }
                        if (replacement === null) {
                            replacement = pickAnyCard(replaceForbiddenNumbers);
                        }
                        if (replacement !== null) {
                            num = replacement;
                        }
                    }

                    const reservedCard = getSpecificCard(num);
                    if (reservedCard === null) {
                        num = getNextCard();
                    }
                }

                if (num !== null) {
                    placedCounts[num] = (placedCounts[num] || 0) + 1;
                    filledCells[i][j] = num;
                }
            }

            return getBoardData();
        }

        function calculatePoolForGenerate(
            width,
            height,
            totalCellCount = null,
            count8Override = null,
            count6Override = null
        ) {
            const count8 = Number.isFinite(Number(count8Override))
                ? Math.max(0, Math.floor(Number(count8Override)))
                : (parseInt(document.getElementById('count8')?.value, 10) || 0);
            const count6 = Number.isFinite(Number(count6Override))
                ? Math.max(0, Math.floor(Number(count6Override)))
                : (parseInt(document.getElementById('count6')?.value, 10) || 0);

            const totalCells = Number.isInteger(totalCellCount) && totalCellCount > 0
                ? totalCellCount
                : (width * height);
            const cardsFrom8 = count8 * 8;
            const cardsFrom6 = count6 * 6;
            const usedCards = cardsFrom8 + cardsFrom6;

            if (usedCards > totalCells) {
                currentPool = [];
                poolCards = [];
                return [];
            }

            const remainingCards = totalCells - usedCards;
            let count4 = Math.floor(remainingCards / 4);
            const remainder = remainingCards % 4;

            let count2 = 0;
            if (remainder >= 2) {
                count2 = 1;
            }

            currentPool = [];
            let num = 1;
            for (let i = 0; i < count8; i++) {
                currentPool.push({ number: num, count: 8 });
                num++;
            }
            for (let i = 0; i < count6; i++) {
                currentPool.push({ number: num, count: 6 });
                num++;
            }
            for (let i = 0; i < count4; i++) {
                currentPool.push({ number: num, count: 4 });
                num++;
            }
            for (let i = 0; i < count2; i++) {
                currentPool.push({ number: num, count: 2 });
                num++;
            }

            poolCards = [];
            currentPool.forEach(poolItem => {
                for (let i = 0; i < poolItem.count; i++) {
                    poolCards.push(poolItem.number);
                }
            });
            poolCards = shuffleArray(poolCards);
        }

        function calculateExportAverages(boardData, direction) {
            if (!boardData || boardData.length === 0 || boardData[0].length === 0) {
                return { adjacentBaselineAvg: 0, directionBothAvg: 0 };
            }

            const height = boardData.length;
            const width = boardData[0].length;
            const isRowDirection = isRowBaseDirection(direction);

            const lineCount = isRowDirection ? height : width;
            const lineSets = [];
            for (let lineIndex = 0; lineIndex < lineCount; lineIndex++) {
                const numberSet = new Set();
                if (isRowDirection) {
                    for (let j = 0; j < width; j++) {
                        const value = boardData[lineIndex]?.[j];
                        if (Number.isInteger(value) && value > 0) numberSet.add(value);
                    }
                } else {
                    for (let i = 0; i < height; i++) {
                        const value = boardData[i]?.[lineIndex];
                        if (Number.isInteger(value) && value > 0) numberSet.add(value);
                    }
                }
                lineSets.push(numberSet);
            }

            const countIntersection = (leftSet, rightSet) => {
                let overlapCount = 0;
                leftSet.forEach((value) => {
                    if (rightSet.has(value)) overlapCount++;
                });
                return overlapCount;
            };

            const adjacentOverlapStats = [];
            for (let lineIndex = 0; lineIndex < lineCount; lineIndex++) {
                let overlapTotal = 0;
                if (lineIndex > 0) {
                    overlapTotal += countIntersection(lineSets[lineIndex], lineSets[lineIndex - 1]);
                }
                if (lineIndex < lineCount - 1) {
                    overlapTotal += countIntersection(lineSets[lineIndex], lineSets[lineIndex + 1]);
                }
                adjacentOverlapStats.push(overlapTotal);
            }
            const adjacentOverlapSum = adjacentOverlapStats.reduce((sum, value) => sum + value, 0);
            const adjacentBaselineAvg = lineCount > 0 ? adjacentOverlapSum / lineCount : 0;

            const mergeSetMap = new Map();
            const lowerSetMap = new Map();
            for (let i = 0; i < height; i++) {
                for (let j = 0; j < width; j++) {
                    const current = boardData[i]?.[j];
                    if (!Number.isInteger(current) || current <= 0) continue;
                    const localDirection = getLocalBaseDirectionByCell(direction, i, j, width, height);
                    if (localDirection === 0) continue;

                    const collectSideNumbersForBoard = (sideType) => {
                        const sideNumbers = new Set();
                        let stepI = 0;
                        let stepJ = 0;
                        if (localDirection === 1) {
                            stepI = sideType === 'top' ? 1 : -1;
                        } else if (localDirection === 2) {
                            stepI = sideType === 'top' ? -1 : 1;
                        } else if (localDirection === 3) {
                            stepJ = sideType === 'top' ? 1 : -1;
                        } else if (localDirection === 4) {
                            stepJ = sideType === 'top' ? -1 : 1;
                        }
                        let ni = i + stepI;
                        let nj = j + stepJ;
                        while (ni >= 0 && ni < height && nj >= 0 && nj < width) {
                            const value = boardData[ni]?.[nj];
                            if (Number.isInteger(value) && value > 0) sideNumbers.add(value);
                            ni += stepI;
                            nj += stepJ;
                        }
                        return sideNumbers;
                    };

                    const upperSet = collectSideNumbersForBoard('top');
                    const lowerSet = collectSideNumbersForBoard('bottom');

                    if (!mergeSetMap.has(current)) mergeSetMap.set(current, new Set());
                    if (!lowerSetMap.has(current)) lowerSetMap.set(current, new Set());

                    upperSet.forEach((value) => mergeSetMap.get(current).add(value));
                    lowerSet.forEach((value) => lowerSetMap.get(current).add(value));
                }
            }

            const numbers = Array.from(mergeSetMap.keys());
            let directionBothSum = 0;
            for (const numberValue of numbers) {
                const upperSet = mergeSetMap.get(numberValue) || new Set();
                const lowerSet = lowerSetMap.get(numberValue) || new Set();
                let bothCount = 0;
                upperSet.forEach((value) => {
                    if (lowerSet.has(value)) bothCount++;
                });
                directionBothSum += bothCount;
            }
            const directionBothAvg = numbers.length > 0 ? directionBothSum / numbers.length : 0;

            return { adjacentBaselineAvg, directionBothAvg };
        }

        function triggerBatchRunCampaignImport() {
            if (isBatchCampaignRunning || isBatchGenerating || isSimulatingPlayGames) return;
            const fileInput = document.getElementById('batchRunCampaignFileInput');
            if (!fileInput) return;
            fileInput.value = '';
            fileInput.click();
        }

        function getBatchCampaignRoundCount() {
            const roundsInput = document.getElementById('batchCampaignRounds');
            const parsed = Number(roundsInput?.value);
            const safeValue = Number.isFinite(parsed)
                ? Math.max(1, Math.min(100, Math.round(parsed)))
                : 1;
            if (roundsInput && roundsInput.value !== String(safeValue)) {
                roundsInput.value = String(safeValue);
            }
            return safeValue;
        }

        async function handleBatchRunCampaignFileChange(event) {
            const fileInput = event?.target || document.getElementById('batchRunCampaignFileInput');
            const file = event?.target?.files?.[0];
            if (!file) return;

            const readJsonFile = () => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const text = typeof reader.result === 'string' ? reader.result : '';
                    resolve(text);
                };
                reader.onerror = () => {
                    reject(reader.error || new Error('读取文件失败'));
                };
                reader.readAsText(file, 'utf-8');
            });

            try {
                const content = await readJsonFile();
                let parsed = null;
                try {
                    parsed = JSON.parse(content);
                } catch (error) {
                    throw new Error(`JSON解析失败：${error.message || '格式错误'}`);
                }

                const levelConfigs = Array.isArray(parsed)
                    ? parsed
                    : (Array.isArray(parsed?.levels) ? parsed.levels : null);
                if (!Array.isArray(levelConfigs) || levelConfigs.length === 0) {
                    throw new Error('JSON中没有可用的关卡数组。');
                }
                const roundCount = getBatchCampaignRoundCount();
                await runBatchCampaign(levelConfigs, roundCount);
            } catch (error) {
                console.error('Failed to run campaign:', error);
                alert(error.message || '跑关失败，请检查配置。');
            } finally {
                if (fileInput) fileInput.value = '';
            }
        }

        function normalizeCampaignConfigKey(key) {
            return String(key || '')
                .replace(/[^a-z0-9]/gi, '')
                .toLowerCase();
        }

        function getCampaignConfigValue(configItem, keyCandidates = []) {
            if (!configItem || typeof configItem !== 'object') return undefined;
            const valueByKey = new Map();
            Object.keys(configItem).forEach((key) => {
                valueByKey.set(normalizeCampaignConfigKey(key), configItem[key]);
            });
            for (const candidate of keyCandidates) {
                const normalizedKey = normalizeCampaignConfigKey(candidate);
                if (valueByKey.has(normalizedKey)) {
                    return valueByKey.get(normalizedKey);
                }
            }
            return undefined;
        }

        function normalizeFloatRange(rawValue, fallbackRange, minLimit, maxLimit) {
            const fallbackMin = Number.isFinite(Number(fallbackRange?.[0]))
                ? Number(fallbackRange[0])
                : 0;
            const fallbackMax = Number.isFinite(Number(fallbackRange?.[1]))
                ? Number(fallbackRange[1])
                : fallbackMin;
            let minValue = fallbackMin;
            let maxValue = fallbackMax;

            if (Array.isArray(rawValue) && rawValue.length >= 2) {
                minValue = Number(rawValue[0]);
                maxValue = Number(rawValue[1]);
            } else if (Number.isFinite(Number(rawValue))) {
                minValue = Number(rawValue);
                maxValue = Number(rawValue);
            }

            if (!Number.isFinite(minValue)) minValue = fallbackMin;
            if (!Number.isFinite(maxValue)) maxValue = fallbackMax;
            if (minValue > maxValue) {
                const temp = minValue;
                minValue = maxValue;
                maxValue = temp;
            }
            minValue = Math.max(minLimit, Math.min(maxLimit, minValue));
            maxValue = Math.max(minLimit, Math.min(maxLimit, maxValue));
            if (minValue > maxValue) {
                minValue = Math.max(minLimit, Math.min(maxLimit, fallbackMin));
                maxValue = Math.max(minLimit, Math.min(maxLimit, fallbackMax));
                if (minValue > maxValue) {
                    const temp = minValue;
                    minValue = maxValue;
                    maxValue = temp;
                }
            }
            return [minValue, maxValue];
        }

        function normalizeIntegerRange(rawValue, fallbackRange, minLimit, maxLimit) {
            const floatRange = normalizeFloatRange(rawValue, fallbackRange, minLimit, maxLimit);
            let minValue = Math.ceil(floatRange[0]);
            let maxValue = Math.floor(floatRange[1]);
            if (minValue > maxValue) {
                const fallbackMin = Number.isFinite(Number(fallbackRange?.[0]))
                    ? Number(fallbackRange[0])
                    : minLimit;
                const fallbackMax = Number.isFinite(Number(fallbackRange?.[1]))
                    ? Number(fallbackRange[1])
                    : fallbackMin;
                minValue = Math.ceil(Math.max(minLimit, Math.min(maxLimit, Math.min(fallbackMin, fallbackMax))));
                maxValue = Math.floor(Math.max(minLimit, Math.min(maxLimit, Math.max(fallbackMin, fallbackMax))));
            }
            return [minValue, maxValue];
        }

        function pickRandomFloatInRange(rangeValue) {
            const minValue = Number(rangeValue?.[0]);
            const maxValue = Number(rangeValue?.[1]);
            if (!Number.isFinite(minValue) || !Number.isFinite(maxValue)) return 0;
            if (maxValue <= minValue) return minValue;
            return minValue + (Math.random() * (maxValue - minValue));
        }

        function normalizeCampaignBoardData(rawBoard) {
            if (!Array.isArray(rawBoard) || rawBoard.length === 0) return null;
            const width = Array.isArray(rawBoard[0]) ? rawBoard[0].length : 0;
            if (width <= 0) return null;
            const boardData = [];
            for (const row of rawBoard) {
                if (!Array.isArray(row) || row.length !== width) return null;
                const normalizedRow = row.map((value) => {
                    const parsed = Number(value);
                    if (!Number.isFinite(parsed)) return EMPTY_CELL_ID;
                    return Math.trunc(parsed);
                });
                boardData.push(normalizedRow);
            }
            return boardData;
        }

        function countRegenerateTargetsInBoard(boardData) {
            if (!Array.isArray(boardData)) return 0;
            let targetCount = 0;
            for (const row of boardData) {
                if (!Array.isArray(row)) continue;
                for (const value of row) {
                    if (getRegenerateTargetMeta(value)) {
                        targetCount++;
                    }
                }
            }
            return targetCount;
        }

        function countInitialAdjacentMatchPairs(boardData) {
            if (!Array.isArray(boardData) || boardData.length === 0) return 0;
            const height = boardData.length;
            const width = boardData[0]?.length || 0;
            if (width <= 0) return 0;
            let pairCount = 0;
            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    const currentBaseId = getCardCountBaseId(boardData[row]?.[col]);
                    if (currentBaseId === null) continue;
                    if (currentBaseId === PLACEHOLDER_CELL_ID) continue;
                    if (col + 1 < width) {
                        const rightBaseId = getCardCountBaseId(boardData[row]?.[col + 1]);
                        if (rightBaseId === currentBaseId) pairCount++;
                    }
                    if (row + 1 < height) {
                        const downBaseId = getCardCountBaseId(boardData[row + 1]?.[col]);
                        if (downBaseId === currentBaseId) pairCount++;
                    }
                }
            }
            return pairCount;
        }

        function buildCount8And6Candidates(fillableCellCount, count8Range, count6Range) {
            const min8 = Number.isFinite(Number(count8Range?.[0])) ? Number(count8Range[0]) : 0;
            const max8 = Number.isFinite(Number(count8Range?.[1])) ? Number(count8Range[1]) : min8;
            const min6 = Number.isFinite(Number(count6Range?.[0])) ? Number(count6Range[0]) : 0;
            const max6 = Number.isFinite(Number(count6Range?.[1])) ? Number(count6Range[1]) : min6;
            const candidates = [];
            for (let count8 = min8; count8 <= max8; count8++) {
                for (let count6 = min6; count6 <= max6; count6++) {
                    const usedCards = count8 * 8 + count6 * 6;
                    if (usedCards > fillableCellCount) continue;
                    const remainingCards = fillableCellCount - usedCards;
                    if (remainingCards < 0 || remainingCards % 2 !== 0) continue;
                    candidates.push({ count8, count6 });
                }
            }
            return candidates;
        }

        function parseCampaignLevelEntry(rawItem, fallbackLevel) {
            if (!rawItem || typeof rawItem !== 'object') {
                return { valid: false, message: '关卡配置必须是对象。' };
            }

            const levelValue = Number(rawItem.level);
            const level = Number.isFinite(levelValue)
                ? Math.max(1, Math.trunc(levelValue))
                : (fallbackLevel + 1);

            const zhenxingRaw = getCampaignConfigValue(rawItem, ['zhenxing', 'board']);
            const boardTemplate = normalizeCampaignBoardData(zhenxingRaw);
            if (!boardTemplate) {
                return { valid: false, level, message: 'zhenxing棋盘数据格式无效。' };
            }

            const count8Raw = getCampaignConfigValue(rawItem, ['8zhang', 'count8']);
            const count6Raw = getCampaignConfigValue(rawItem, ['6zhang', 'count6']);
            const variable1Raw = getCampaignConfigValue(rawItem, ['Variable_1', 'variable1']);
            const variable2Raw = getCampaignConfigValue(rawItem, ['Variable_2', 'variable2']);
            const variable3Raw = getCampaignConfigValue(rawItem, ['Variable_3', 'variable3']);
            const variable5Raw = getCampaignConfigValue(rawItem, ['Variable_5', 'variable5']);
            const shenglvRaw = getCampaignConfigValue(rawItem, ['shenglv', 'winrate']);
            const matchNumRaw = getCampaignConfigValue(rawItem, ['match_num', 'matchnum', 'matchNum']);
            const remainRaw = getCampaignConfigValue(
                rawItem,
                ['remain', 'remainpercent', 'remaining', 'shengyu']
            );

            const count8Range = normalizeIntegerRange(count8Raw, [0, 0], 0, 200);
            const count6Range = normalizeIntegerRange(count6Raw, [0, 0], 0, 200);
            const sameLieRange = normalizeFloatRange(variable1Raw, [0.1, 0.1], 0, 1);
            const sameNumRange = normalizeFloatRange(variable2Raw, [0.1, 0.1], 0, 1);
            const xianglinSameRange = normalizeFloatRange(variable3Raw, [0.1, 0.1], 0, 1);
            const distanceRange = normalizeFloatRange(variable5Raw, [0.1, 0.1], 0, 1);
            const winRateRange = normalizeFloatRange(shenglvRaw, [0, 100], 0, 100);
            const remainRange = normalizeFloatRange(remainRaw, [0, 100], 0, 100);
            const maxAdjacentPairCount =
                (boardTemplate.length * Math.max(0, (boardTemplate[0]?.length || 0) - 1)) +
                ((boardTemplate.length - 1) * (boardTemplate[0]?.length || 0));
            const matchNumRange = normalizeIntegerRange(
                matchNumRaw,
                [0, maxAdjacentPairCount],
                0,
                maxAdjacentPairCount
            );

            return {
                valid: true,
                level,
                boardTemplate,
                count8Range,
                count6Range,
                sameLieRange,
                sameNumRange,
                xianglinSameRange,
                distanceRange,
                winRateRange,
                remainRange,
                matchNumRange
            };
        }

        async function runBatchCampaign(levelConfigs, roundCount = 1) {
            const MAX_ATTEMPTS_PER_LEVEL = 100;
            const SIMULATE_GAME_COUNT = 100;

            if (isBatchCampaignRunning) return;
            if (isBatchGenerating) {
                alert('当前正在批量导出，请稍后再试。');
                return;
            }
            if (isSimulatingPlayGames) {
                alert('当前正在执行模拟100局，请稍后再试。');
                return;
            }

            const runButton = document.getElementById('btnBatchRunCampaign');
            const info = document.getElementById('info');
            const originalButtonText = runButton ? runButton.textContent : '';
            const totalLevels = Array.isArray(levelConfigs) ? levelConfigs.length : 0;
            if (totalLevels <= 0) {
                alert('没有可跑关的配置。');
                return;
            }
            const totalRounds = Number.isFinite(Number(roundCount))
                ? Math.max(1, Math.min(100, Math.round(Number(roundCount))))
                : 1;
            let overallSuccessCount = 0;
            let overallTimeoutCount = 0;
            let overallInvalidCount = 0;

            isBatchCampaignRunning = true;
            setSimulationInteractionLock(true);
            if (runButton) {
                runButton.disabled = true;
                runButton.textContent = '跑关中...';
            }

            try {
                for (let roundIndex = 1; roundIndex <= totalRounds; roundIndex++) {
                    let exportResult = '';
                    let successCount = 0;
                    let timeoutCount = 0;
                    let invalidCount = 0;
                    for (let index = 0; index < totalLevels; index++) {
                        const parsedLevel = parseCampaignLevelEntry(levelConfigs[index], index);
                        const displayLevel = parsedLevel.level || (index + 1);
                        const roundPrefix = totalRounds > 1
                            ? `第${roundIndex}/${totalRounds}轮 `
                            : '';

                        if (!parsedLevel.valid) {
                            invalidCount++;
                            if (info) {
                                info.textContent = `${roundPrefix}第${displayLevel}关配置无效，已跳过：` +
                                    `${parsedLevel.message || '未知错误'}`;
                            }
                            continue;
                        }

                        const fillableCellCount = countRegenerateTargetsInBoard(parsedLevel.boardTemplate);
                        if (fillableCellCount <= 0 || fillableCellCount % 2 !== 0) {
                            invalidCount++;
                            if (info) {
                                info.textContent = `${roundPrefix}第${displayLevel}关无可生成偶数格子，已跳过。`;
                            }
                            continue;
                        }

                        const countCandidates = buildCount8And6Candidates(
                            fillableCellCount,
                            parsedLevel.count8Range,
                            parsedLevel.count6Range
                        );
                        if (countCandidates.length === 0) {
                            invalidCount++;
                            if (info) {
                                info.textContent =
                                    `${roundPrefix}第${displayLevel}关的8张/6张范围无可用组合，已跳过。`;
                            }
                            continue;
                        }

                        let matchedBoardData = null;
                        let matchedWinRate = null;
                        for (let attempt = 1; attempt <= MAX_ATTEMPTS_PER_LEVEL; attempt++) {
                            const countCandidate =
                                countCandidates[Math.floor(Math.random() * countCandidates.length)];
                            const generateResult = buildRegenerateFillPlanForBoard(
                                parsedLevel.boardTemplate,
                                {
                                    count8: countCandidate.count8,
                                    count6: countCandidate.count6,
                                    sameLie: pickRandomFloatInRange(parsedLevel.sameLieRange),
                                    sameNum: pickRandomFloatInRange(parsedLevel.sameNumRange),
                                    xianglinSame: pickRandomFloatInRange(parsedLevel.xianglinSameRange),
                                    distanceCtrl: pickRandomFloatInRange(parsedLevel.distanceRange)
                                }
                            );

                            if (!generateResult.success) continue;

                            const legality = validateBoardPairLegality(generateResult.boardData);
                            if (!legality.valid) continue;
                            const adjacentMatchCount =
                                countInitialAdjacentMatchPairs(generateResult.boardData);
                            if (
                                adjacentMatchCount < parsedLevel.matchNumRange[0] ||
                                adjacentMatchCount > parsedLevel.matchNumRange[1]
                            ) {
                                continue;
                            }

                            if (runButton) {
                                runButton.textContent =
                                    `${roundPrefix}跑关 ${index + 1}/${totalLevels} ` +
                                    `(${attempt}/${MAX_ATTEMPTS_PER_LEVEL})`;
                            }
                            if (info && (attempt === 1 || attempt % 5 === 0)) {
                                info.textContent = `${roundPrefix}跑关中：第${displayLevel}关，尝试 ` +
                                    `${attempt}/${MAX_ATTEMPTS_PER_LEVEL}`;
                            }

                            const simulationResult = await simulateBoardWinRate(
                                generateResult.boardData,
                                0,
                                SIMULATE_GAME_COUNT,
                                null,
                                {
                                    winRateRange: parsedLevel.winRateRange,
                                    enableUnreachableEarlyStop: true
                                }
                            );
                            if (simulationResult.unreachable) {
                                continue;
                            }
                            const winRate = simulationResult.winRate;
                            const remainPercent = Number(simulationResult.failedRemainPercent) || 0;
                            if (
                                winRate >= parsedLevel.winRateRange[0] &&
                                winRate <= parsedLevel.winRateRange[1] &&
                                remainPercent >= parsedLevel.remainRange[0] &&
                                remainPercent <= parsedLevel.remainRange[1]
                            ) {
                                matchedBoardData = generateResult.boardData;
                                matchedWinRate = winRate;
                                break;
                            }

                            if (attempt % 2 === 0) {
                                await waitForMs(0);
                            }
                        }

                        if (!matchedBoardData) {
                            timeoutCount++;
                            if (info) {
                                info.textContent = `${roundPrefix}第${displayLevel}关连续` +
                                    `${MAX_ATTEMPTS_PER_LEVEL}次未命中筛选条件，已跳过。`;
                            }
                            continue;
                        }

                        exportResult += `${displayLevel}\t${JSON.stringify(matchedBoardData)}\t` +
                            `${Number(matchedWinRate || 0).toFixed(2)}\n`;
                        successCount++;

                        if (info) {
                            info.textContent =
                                `${roundPrefix}第${displayLevel}关完成（${successCount}/${totalLevels}）。`;
                        }
                    }

                    const now = new Date();
                    const stamp = [
                        now.getFullYear(),
                        String(now.getMonth() + 1).padStart(2, '0'),
                        String(now.getDate()).padStart(2, '0'),
                        '_',
                        String(now.getHours()).padStart(2, '0'),
                        String(now.getMinutes()).padStart(2, '0'),
                        String(now.getSeconds()).padStart(2, '0')
                    ].join('');
                    const roundLabel = totalRounds > 1 ? `第${roundIndex}轮_` : '';
                    const blob = new Blob([exportResult], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `跑关结果_${roundLabel}${successCount}关_${stamp}.txt`;
                    a.click();
                    setTimeout(() => URL.revokeObjectURL(url), 0);

                    overallSuccessCount += successCount;
                    overallTimeoutCount += timeoutCount;
                    overallInvalidCount += invalidCount;

                    if (info) {
                        const roundPrefix = totalRounds > 1 ? `第${roundIndex}轮完成：` : '跑关完成：';
                        info.textContent =
                            `${roundPrefix}成功${successCount}关，超限跳过${timeoutCount}关，` +
                            `配置跳过${invalidCount}关。`;
                    }
                }

                if (info && totalRounds > 1) {
                    info.textContent =
                        `跑关全部完成（${totalRounds}轮）：成功${overallSuccessCount}关，` +
                        `超限跳过${overallTimeoutCount}关，配置跳过${overallInvalidCount}关。`;
                }
            } finally {
                isBatchCampaignRunning = false;
                setSimulationInteractionLock(false);
                if (runButton) {
                    runButton.disabled = false;
                    runButton.textContent = originalButtonText || '跑关导出';
                }
            }
        }

        async function batchGenerate() {
            const SIMULATE_GAME_COUNT = 100;
            if (isBatchGenerating || isBatchCampaignRunning || isSimulatingPlayGames) return;
            const count = parseInt(document.getElementById('batchCount').value) || 10;
            const sameLie = getProbabilityValue('sameLie', 0.1);
            const sameNum = getProbabilityValue('sameNum', 0.1);
            const xianglinSame = getProbabilityValue('xianglinSame', 0.1);
            const directionBothCtrl = getProbabilityValue('directionBothCtrl', 0.5);
            const distanceCtrl = getProbabilityValue('distanceCtrl', 0.1);

            let result = '';
            const { width, height } = getCurrentBoardDimensions();
            const batchButton = document.getElementById('btnBatchGenerate');
            const info = document.getElementById('info');

            isBatchGenerating = true;
            setSimulationInteractionLock(true);
            if (batchButton) batchButton.disabled = true;

            try {
                for (let i = 0; i < count; i++) {
                    const boardData = generateSingleLevel(
                        0,
                        sameLie,
                        sameNum,
                        xianglinSame,
                        directionBothCtrl,
                        distanceCtrl
                    );
                    const boardStr = JSON.stringify(boardData);
                    const simulationResult = await simulateBoardWinRate(
                        boardData,
                        0,
                        SIMULATE_GAME_COUNT
                    );
                    result += `${i + 1}\t${boardStr}\t${simulationResult.winRate.toFixed(2)}\n`;
                    if (info) {
                        info.textContent = `批量导出中：${i + 1}/${count}`;
                    }
                }

                const blob = new Blob([result], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `关卡批量生成_${width}x${height}_${count}个.txt`;
                a.click();
                setTimeout(() => URL.revokeObjectURL(url), 0);
            } catch (error) {
                console.error('Batch export failed:', error);
                alert('批量导出失败，请重试。');
            } finally {
                isBatchGenerating = false;
                setSimulationInteractionLock(false);
                if (batchButton) batchButton.disabled = false;
            }
        }

        function init() {
            setBoardSizeSpec(DEFAULT_BOARD_SIZE_SPEC, { refreshPool: false, refreshInfo: false });
            loadConfigGroupsFromStorage();
            renderEditorTools();
            renderSavedLevelList();
            initInfoMutationObserver();
            renderBoardBackgroundDropdown();
            applyBoardBackground(selectedBoardBackgroundIndex);
            updateSaveCurrentLevelButtonState();
            const board = document.getElementById('board');
            if (board) {
                board.addEventListener('mousedown', handleBoardCellMouseDown);
                board.addEventListener('mousemove', handleBoardCellMouseMove);
                board.addEventListener('mouseleave', handleBoardCellMouseLeave);
                board.addEventListener('click', handleBoardCellClick);
                board.addEventListener('contextmenu', handleBoardCellContextMenu);
                generateBoard();
            } else {
                window.addEventListener('DOMContentLoaded', () => {
                    loadConfigGroupsFromStorage();
                    renderEditorTools();
                    renderBoardBackgroundDropdown();
                    applyBoardBackground(selectedBoardBackgroundIndex);
                    const readyBoard = document.getElementById('board');
                    if (readyBoard) {
                        readyBoard.addEventListener('mousedown', handleBoardCellMouseDown);
                        readyBoard.addEventListener('mousemove', handleBoardCellMouseMove);
                        readyBoard.addEventListener('mouseleave', handleBoardCellMouseLeave);
                        readyBoard.addEventListener('click', handleBoardCellClick);
                        readyBoard.addEventListener('contextmenu', handleBoardCellContextMenu);
                    }
                    generateBoard();
                    updatePlayModeButton();
                    renderSavedLevelList();
                });
            }
            document.addEventListener('click', () => {
                closeSavedLevelContextMenu();
                hideSavedLevelPreview();
                closeBoardBackgroundDropdown();
            });
            document.addEventListener('contextmenu', (event) => {
                const target = event.target;
                if (target && target.closest && target.closest('#savedLevelContextMenu')) return;
                if (target && target.closest && target.closest('.saved-level-item')) return;
                if (target && target.closest && target.closest('#boardBgDropdown')) return;
                closeSavedLevelContextMenu();
                hideSavedLevelPreview();
                closeBoardBackgroundDropdown();
            });
            document.addEventListener('mousemove', handleDocumentPlayDragMouseMove);
            document.addEventListener('mouseup', handleEditorBrushMouseUp);
            const savedMenu = document.getElementById('savedLevelContextMenu');
            if (savedMenu) {
                savedMenu.addEventListener('contextmenu', (event) => event.preventDefault());
                savedMenu.addEventListener('click', (event) => event.stopPropagation());
            }
            window.addEventListener('resize', () => {
                closeSavedLevelContextMenu();
                hideSavedLevelPreview();
                closeBoardBackgroundDropdown();
            });
            window.addEventListener('blur', () => {
                stopEditorBrush();
                cancelPlayDrag(true);
                closeSavedLevelContextMenu();
                hideSavedLevelPreview();
                closeBoardBackgroundDropdown();
            });
            document.addEventListener('keydown', handleGlobalShortcut);
            updatePlayModeButton();
            window.addEventListener('resize', scaleBoard);
        }

        function scaleBoard() {
            const wrapper = document.getElementById('boardWrapper');
            const container = document.querySelector('.board-container');
            if (!wrapper || !container) return;

            requestAnimationFrame(() => {
                const SCALE_SAFE_MARGIN = 2;
                const EXTRA_VERTICAL_CELL_SPACES = 2; // top + bottom
                const containerStyle = window.getComputedStyle(container);
                const horizontalPadding =
                    parseFloat(containerStyle.paddingLeft || '0') +
                    parseFloat(containerStyle.paddingRight || '0');
                const verticalPadding =
                    parseFloat(containerStyle.paddingTop || '0') +
                    parseFloat(containerStyle.paddingBottom || '0');
                const topTools = container.querySelector('.board-top-tools');
                const topToolsMarginBottom = topTools
                    ? parseFloat(window.getComputedStyle(topTools).marginBottom || '0')
                    : 0;
                const topToolsHeight = topTools ? topTools.offsetHeight + topToolsMarginBottom : 0;

                const containerWidth =
                    container.clientWidth - horizontalPadding - SCALE_SAFE_MARGIN;
                const containerHeight =
                    container.clientHeight -
                    verticalPadding -
                    topToolsHeight -
                    SCALE_SAFE_MARGIN;
                const boardWidth = wrapper.scrollWidth;
                const boardHeight = wrapper.scrollHeight;
                const { stepY } = getCellStepDistance();
                const extraVerticalSpace = Math.max(0, stepY) * EXTRA_VERTICAL_CELL_SPACES;
                const virtualBoardHeight = boardHeight + extraVerticalSpace;

                let scale = 1;
                if (boardWidth > containerWidth && containerWidth > 0) {
                    scale = Math.min(scale, containerWidth / boardWidth);
                }
                if (virtualBoardHeight > containerHeight && containerHeight > 0) {
                    scale = Math.min(scale, containerHeight / virtualBoardHeight);
                }

                const scaledBoardWidth = boardWidth * scale;
                const scaledBoardHeight = boardHeight * scale;
                const offsetX = Math.max(0, (containerWidth - scaledBoardWidth) / 2);
                const offsetY = Math.max(0, (containerHeight - scaledBoardHeight) / 2);

                wrapper.style.transform =
                    `translate(${offsetX.toFixed(2)}px, ${offsetY.toFixed(2)}px) scale(${scale.toFixed(3)})`;
            });
        }

        function isShortcutBlockedByFocus(target) {
            if (!target || typeof target.closest !== 'function') return false;
            return Boolean(target.closest('input, textarea, select, [contenteditable="true"]'));
        }

        function handleGlobalShortcut(event) {
            if (!event || event.defaultPrevented) return;
            if (event.repeat) return;
            const key = String(event.key || '').toLowerCase();
            if (!key) return;
            const hasCtrlOrMeta = event.ctrlKey || event.metaKey;

            if (hasCtrlOrMeta && !event.altKey && key === 's') {
                event.preventDefault();
                saveSavedLevelsToCurrentFile();
                return;
            }

            if (hasCtrlOrMeta || event.altKey) return;
            if (isShortcutBlockedByFocus(event.target)) return;
            if (isBatchGenerating || isBatchCampaignRunning) return;

            if (key === 'r') {
                event.preventDefault();
                fillBoard();
                return;
            }
            if (key === 'n') {
                event.preventDefault();
                refreshBoardWithPlaceholder();
                return;
            }
            if (key === 'c') {
                event.preventDefault();
                clearBoard();
                return;
            }
            if (key === 's') {
                event.preventDefault();
                if (editingSavedLevelIndex >= 0) {
                    saveEditingSavedLevel();
                } else {
                    saveCurrentLevelToList();
                }
                return;
            }
            if (event.code === 'Space' || key === ' ') {
                event.preventDefault();
                simulatePlayGames();
            }
        }

        init();
    </script>
</body>
</html>
